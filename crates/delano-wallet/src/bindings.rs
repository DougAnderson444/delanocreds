// Generated by `wit-bindgen` 0.35.0. DO NOT EDIT!
// Options used:
//   * additional derives ["PartialEq"]
#[allow(dead_code)]
pub mod delano {
  #[allow(dead_code)]
  pub mod wallet {
    #[allow(dead_code, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// An attribute is a 32 bytes hash value
      pub type Attribute = _rt::Vec::<u8>;
      pub type Entry = _rt::Vec::<Attribute>;
      pub type Selected = _rt::Vec::<Entry>;
      /// If you want to redact an Entry containing an Attribute,
      /// construct a redactable record with all Entries and the list of Attributes to redact.
      #[derive(Clone, PartialEq)]
      pub struct Redactables {
        pub entries: _rt::Vec::<Entry>,
        pub remove: _rt::Vec::<Attribute>,
      }
      impl ::core::fmt::Debug for Redactables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Redactables").field("entries", &self.entries).field("remove", &self.remove).finish()
        }
      }
      /// Configuration of an Offer. Can set 3 things:
      /// 1) without-attribute: an optional redactable record of attributes to redact,
      /// 2) additional-entry: an optional single additional entry,
      /// 3) max-entries: the maximum number of entries the delegated party can add to the credential.
      #[derive(Clone, PartialEq)]
      pub struct OfferConfig {
        pub redact: Option<Redactables>,
        pub additional_entry: Option<Entry>,
        /// Optionally reduces the number of entries that can be added to the credential.
        pub max_entries: Option<u8>,
      }
      impl ::core::fmt::Debug for OfferConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OfferConfig").field("redact", &self.redact).field("additional-entry", &self.additional_entry).field("max-entries", &self.max_entries).finish()
        }
      }
      /// A compressed signature
      #[derive(Clone, PartialEq)]
      pub struct SignatureCompressed {
        pub z: _rt::Vec::<u8>,
        pub y_g1: _rt::Vec::<u8>,
        pub y_hat: _rt::Vec::<u8>,
        pub t: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for SignatureCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SignatureCompressed").field("z", &self.z).field("y-g1", &self.y_g1).field("y-hat", &self.y_hat).field("t", &self.t).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct ParamSetCommitmentCompressed {
        pub pp_commit_g1: _rt::Vec::<_rt::Vec::<u8>>,
        pub pp_commit_g2: _rt::Vec::<_rt::Vec::<u8>>,
      }
      impl ::core::fmt::Debug for ParamSetCommitmentCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ParamSetCommitmentCompressed").field("pp-commit-g1", &self.pp_commit_g1).field("pp-commit-g2", &self.pp_commit_g2).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub enum VkCompressed {
        G1(_rt::Vec::<u8>),
        G2(_rt::Vec::<u8>),
      }
      impl ::core::fmt::Debug for VkCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            VkCompressed::G1(e) => {
              f.debug_tuple("VkCompressed::G1").field(e).finish()
            }
            VkCompressed::G2(e) => {
              f.debug_tuple("VkCompressed::G2").field(e).finish()
            }
          }
        }
      }
      /// Issuer public parameters, compressed
      #[derive(Clone, PartialEq)]
      pub struct IssuerPublicCompressed {
        pub parameters: ParamSetCommitmentCompressed,
        pub vk: _rt::Vec::<VkCompressed>,
      }
      impl ::core::fmt::Debug for IssuerPublicCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IssuerPublicCompressed").field("parameters", &self.parameters).field("vk", &self.vk).finish()
        }
      }
      /// A compressed version of the Credential
      #[derive(Clone, PartialEq)]
      pub struct CredentialCompressed {
        pub sigma: SignatureCompressed,
        pub update_key: Option<_rt::Vec::<_rt::Vec::<_rt::Vec::<u8>>>>,
        pub commitment_vector: _rt::Vec::<_rt::Vec::<u8>>,
        pub opening_vector: _rt::Vec::<_rt::Vec::<u8>>,
        pub issuer_public: IssuerPublicCompressed,
      }
      impl ::core::fmt::Debug for CredentialCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CredentialCompressed").field("sigma", &self.sigma).field("update-key", &self.update_key).field("commitment-vector", &self.commitment_vector).field("opening-vector", &self.opening_vector).field("issuer-public", &self.issuer_public).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct Provables {
        pub credential: CredentialCompressed,
        pub entries: _rt::Vec::<Entry>,
        pub selected: _rt::Vec::<Attribute>,
        pub nonce: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for Provables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Provables").field("credential", &self.credential).field("entries", &self.entries).field("selected", &self.selected).field("nonce", &self.nonce).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct PedersenCompressed {
        pub h: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for PedersenCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PedersenCompressed").field("h", &self.h).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct DamgardTransformCompressed {
        pub pedersen: PedersenCompressed,
      }
      impl ::core::fmt::Debug for DamgardTransformCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DamgardTransformCompressed").field("pedersen", &self.pedersen).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct PedersenOpenCompressed {
        pub open_randomness: _rt::Vec::<u8>,
        pub announce_randomness: _rt::Vec::<u8>,
        pub announce_element: Option<_rt::Vec::<u8>>,
      }
      impl ::core::fmt::Debug for PedersenOpenCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PedersenOpenCompressed").field("open-randomness", &self.open_randomness).field("announce-randomness", &self.announce_randomness).field("announce-element", &self.announce_element).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct NymProofCompressed {
        pub challenge: _rt::Vec::<u8>,
        pub pedersen_open: PedersenOpenCompressed,
        pub pedersen_commit: _rt::Vec::<u8>,
        pub public_key: _rt::Vec::<u8>,
        pub response: _rt::Vec::<u8>,
        pub damgard: DamgardTransformCompressed,
      }
      impl ::core::fmt::Debug for NymProofCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("NymProofCompressed").field("challenge", &self.challenge).field("pedersen-open", &self.pedersen_open).field("pedersen-commit", &self.pedersen_commit).field("public-key", &self.public_key).field("response", &self.response).field("damgard", &self.damgard).finish()
        }
      }
      /// Issuer config: Default config creates (issues) a credential to yourself.
      /// Provide a config to offer it to someone else's nym, and optionally verify it with a nonce.
      #[derive(Clone, PartialEq)]
      pub struct IssueOptions {
        pub nymproof: NymProofCompressed,
        pub nonce: Option<_rt::Vec::<u8>>,
      }
      impl ::core::fmt::Debug for IssueOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IssueOptions").field("nymproof", &self.nymproof).field("nonce", &self.nonce).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct CredProofCompressed {
        pub sigma: SignatureCompressed,
        pub commitment_vector: _rt::Vec::<_rt::Vec::<u8>>,
        pub witness_pi: _rt::Vec::<u8>,
        pub nym_proof: NymProofCompressed,
      }
      impl ::core::fmt::Debug for CredProofCompressed {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CredProofCompressed").field("sigma", &self.sigma).field("commitment-vector", &self.commitment_vector).field("witness-pi", &self.witness_pi).field("nym-proof", &self.nym_proof).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct Proven {
        pub proof: CredProofCompressed,
        pub selected: Selected,
      }
      impl ::core::fmt::Debug for Proven {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Proven").field("proof", &self.proof).field("selected", &self.selected).finish()
        }
      }
      #[derive(Clone, PartialEq)]
      pub struct Verifiables {
        pub proof: CredProofCompressed,
        pub issuer_public: IssuerPublicCompressed,
        pub nonce: Option<_rt::Vec::<u8>>,
        pub selected: Selected,
      }
      impl ::core::fmt::Debug for Verifiables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Verifiables").field("proof", &self.proof).field("issuer-public", &self.issuer_public).field("nonce", &self.nonce).field("selected", &self.selected).finish()
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod seed_keeper {
  #[allow(dead_code)]
  pub mod wallet {
    #[allow(dead_code, clippy::all)]
    pub mod config {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the plaintext seed
      pub fn get_seed() -> Result<_rt::Vec::<u8>,_rt::String>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "seed-keeper:wallet/config@0.1.0")]
          extern "C" {
            #[link_name = "get-seed"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let len4 = l3;

                _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr0.add(4).cast::<*mut u8>();
                let l6 = *ptr0.add(8).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod exports {
  #[allow(dead_code)]
  pub mod delano {
    #[allow(dead_code)]
    pub mod wallet {
      #[allow(dead_code, clippy::all)]
      pub mod actions {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        pub type Attribute = super::super::super::super::delano::wallet::types::Attribute;
        pub type Provables = super::super::super::super::delano::wallet::types::Provables;
        pub type Verifiables = super::super::super::super::delano::wallet::types::Verifiables;
        pub type OfferConfig = super::super::super::super::delano::wallet::types::OfferConfig;
        pub type IssueOptions = super::super::super::super::delano::wallet::types::IssueOptions;
        pub type Entry = super::super::super::super::delano::wallet::types::Entry;
        pub type Proven = super::super::super::super::delano::wallet::types::Proven;
        pub type CredentialCompressed = super::super::super::super::delano::wallet::types::CredentialCompressed;
        pub type NymProofCompressed = super::super::super::super::delano::wallet::types::NymProofCompressed;
        pub type IssuerPublicCompressed = super::super::super::super::delano::wallet::types::IssuerPublicCompressed;
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_get_nym_proof_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let len0 = arg1;
        let result1 = T::get_nym_proof(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0));
        let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
        match result1 {
          Ok(e) => { {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
            let super::super::super::super::delano::wallet::types::NymProofCompressed{ challenge:challenge3, pedersen_open:pedersen_open3, pedersen_commit:pedersen_commit3, public_key:public_key3, response:response3, damgard:damgard3, } = e;
            let vec4 = (challenge3).into_boxed_slice();
            let ptr4 = vec4.as_ptr().cast::<u8>();
            let len4 = vec4.len();
            ::core::mem::forget(vec4);
            *ptr2.add(8).cast::<usize>() = len4;
            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
            let super::super::super::super::delano::wallet::types::PedersenOpenCompressed{ open_randomness:open_randomness5, announce_randomness:announce_randomness5, announce_element:announce_element5, } = pedersen_open3;
            let vec6 = (open_randomness5).into_boxed_slice();
            let ptr6 = vec6.as_ptr().cast::<u8>();
            let len6 = vec6.len();
            ::core::mem::forget(vec6);
            *ptr2.add(16).cast::<usize>() = len6;
            *ptr2.add(12).cast::<*mut u8>() = ptr6.cast_mut();
            let vec7 = (announce_randomness5).into_boxed_slice();
            let ptr7 = vec7.as_ptr().cast::<u8>();
            let len7 = vec7.len();
            ::core::mem::forget(vec7);
            *ptr2.add(24).cast::<usize>() = len7;
            *ptr2.add(20).cast::<*mut u8>() = ptr7.cast_mut();
            match announce_element5 {
              Some(e) => {
                *ptr2.add(28).cast::<u8>() = (1i32) as u8;
                let vec8 = (e).into_boxed_slice();
                let ptr8 = vec8.as_ptr().cast::<u8>();
                let len8 = vec8.len();
                ::core::mem::forget(vec8);
                *ptr2.add(36).cast::<usize>() = len8;
                *ptr2.add(32).cast::<*mut u8>() = ptr8.cast_mut();
              },
              None => {
                {
                  *ptr2.add(28).cast::<u8>() = (0i32) as u8;
                }
              },
            };let vec9 = (pedersen_commit3).into_boxed_slice();
            let ptr9 = vec9.as_ptr().cast::<u8>();
            let len9 = vec9.len();
            ::core::mem::forget(vec9);
            *ptr2.add(44).cast::<usize>() = len9;
            *ptr2.add(40).cast::<*mut u8>() = ptr9.cast_mut();
            let vec10 = (public_key3).into_boxed_slice();
            let ptr10 = vec10.as_ptr().cast::<u8>();
            let len10 = vec10.len();
            ::core::mem::forget(vec10);
            *ptr2.add(52).cast::<usize>() = len10;
            *ptr2.add(48).cast::<*mut u8>() = ptr10.cast_mut();
            let vec11 = (response3).into_boxed_slice();
            let ptr11 = vec11.as_ptr().cast::<u8>();
            let len11 = vec11.len();
            ::core::mem::forget(vec11);
            *ptr2.add(60).cast::<usize>() = len11;
            *ptr2.add(56).cast::<*mut u8>() = ptr11.cast_mut();
            let super::super::super::super::delano::wallet::types::DamgardTransformCompressed{ pedersen:pedersen12, } = damgard3;
            let super::super::super::super::delano::wallet::types::PedersenCompressed{ h:h13, } = pedersen12;
            let vec14 = (h13).into_boxed_slice();
            let ptr14 = vec14.as_ptr().cast::<u8>();
            let len14 = vec14.len();
            ::core::mem::forget(vec14);
            *ptr2.add(68).cast::<usize>() = len14;
            *ptr2.add(64).cast::<*mut u8>() = ptr14.cast_mut();
          } },
          Err(e) => { {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
            let vec15 = (e.into_bytes()).into_boxed_slice();
            let ptr15 = vec15.as_ptr().cast::<u8>();
            let len15 = vec15.len();
            ::core::mem::forget(vec15);
            *ptr2.add(8).cast::<usize>() = len15;
            *ptr2.add(4).cast::<*mut u8>() = ptr15.cast_mut();
          } },
        };ptr2
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __post_return_get_nym_proof<T: Guest>(arg0: *mut u8,) {
        let l0 = i32::from(*arg0.add(0).cast::<u8>());
        match l0 {
          0 => {
            let l1 = *arg0.add(4).cast::<*mut u8>();
            let l2 = *arg0.add(8).cast::<usize>();
            let base3 = l1;
            let len3 = l2;
            _rt::cabi_dealloc(base3, len3 * 1, 1);
            let l4 = *arg0.add(12).cast::<*mut u8>();
            let l5 = *arg0.add(16).cast::<usize>();
            let base6 = l4;
            let len6 = l5;
            _rt::cabi_dealloc(base6, len6 * 1, 1);
            let l7 = *arg0.add(20).cast::<*mut u8>();
            let l8 = *arg0.add(24).cast::<usize>();
            let base9 = l7;
            let len9 = l8;
            _rt::cabi_dealloc(base9, len9 * 1, 1);
            let l10 = i32::from(*arg0.add(28).cast::<u8>());
            match l10 {
              0 => (),
              _ => {
                let l11 = *arg0.add(32).cast::<*mut u8>();
                let l12 = *arg0.add(36).cast::<usize>();
                let base13 = l11;
                let len13 = l12;
                _rt::cabi_dealloc(base13, len13 * 1, 1);
              },
            }
            let l14 = *arg0.add(40).cast::<*mut u8>();
            let l15 = *arg0.add(44).cast::<usize>();
            let base16 = l14;
            let len16 = l15;
            _rt::cabi_dealloc(base16, len16 * 1, 1);
            let l17 = *arg0.add(48).cast::<*mut u8>();
            let l18 = *arg0.add(52).cast::<usize>();
            let base19 = l17;
            let len19 = l18;
            _rt::cabi_dealloc(base19, len19 * 1, 1);
            let l20 = *arg0.add(56).cast::<*mut u8>();
            let l21 = *arg0.add(60).cast::<usize>();
            let base22 = l20;
            let len22 = l21;
            _rt::cabi_dealloc(base22, len22 * 1, 1);
            let l23 = *arg0.add(64).cast::<*mut u8>();
            let l24 = *arg0.add(68).cast::<usize>();
            let base25 = l23;
            let len25 = l24;
            _rt::cabi_dealloc(base25, len25 * 1, 1);
          },
          _ => {
            let l26 = *arg0.add(4).cast::<*mut u8>();
            let l27 = *arg0.add(8).cast::<usize>();
            _rt::cabi_dealloc(l26, l27, 1);
          },
        }
      }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_issue_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
      let l1 = *arg0.add(4).cast::<usize>();
      let base5 = l0;
      let len5 = l1;
      let mut result5 = _rt::Vec::with_capacity(len5);
      for i in 0..len5 {
        let base = base5.add(i * 8);
        let e5 = {
          let l2 = *base.add(0).cast::<*mut u8>();
          let l3 = *base.add(4).cast::<usize>();
          let len4 = l3;

          _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
        };
        result5.push(e5);
      }
      _rt::cabi_dealloc(base5, len5 * 8, 4);
      let l6 = i32::from(*arg0.add(8).cast::<u8>());
      let l7 = i32::from(*arg0.add(12).cast::<u8>());
      let result37 = T::issue(result5, l6 as u8, match l7 {
        0 => None,
        1 => {
          let e = {
            let l8 = *arg0.add(16).cast::<*mut u8>();
            let l9 = *arg0.add(20).cast::<usize>();
            let len10 = l9;
            let l11 = *arg0.add(24).cast::<*mut u8>();
            let l12 = *arg0.add(28).cast::<usize>();
            let len13 = l12;
            let l14 = *arg0.add(32).cast::<*mut u8>();
            let l15 = *arg0.add(36).cast::<usize>();
            let len16 = l15;
            let l17 = i32::from(*arg0.add(40).cast::<u8>());
            let l21 = *arg0.add(52).cast::<*mut u8>();
            let l22 = *arg0.add(56).cast::<usize>();
            let len23 = l22;
            let l24 = *arg0.add(60).cast::<*mut u8>();
            let l25 = *arg0.add(64).cast::<usize>();
            let len26 = l25;
            let l27 = *arg0.add(68).cast::<*mut u8>();
            let l28 = *arg0.add(72).cast::<usize>();
            let len29 = l28;
            let l30 = *arg0.add(76).cast::<*mut u8>();
            let l31 = *arg0.add(80).cast::<usize>();
            let len32 = l31;
            let l33 = i32::from(*arg0.add(84).cast::<u8>());

            super::super::super::super::delano::wallet::types::IssueOptions{
              nymproof: super::super::super::super::delano::wallet::types::NymProofCompressed{
                challenge: _rt::Vec::from_raw_parts(l8.cast(), len10, len10),
                pedersen_open: super::super::super::super::delano::wallet::types::PedersenOpenCompressed{
                  open_randomness: _rt::Vec::from_raw_parts(l11.cast(), len13, len13),
                  announce_randomness: _rt::Vec::from_raw_parts(l14.cast(), len16, len16),
                  announce_element: match l17 {
                    0 => None,
                    1 => {
                      let e = {
                        let l18 = *arg0.add(44).cast::<*mut u8>();
                        let l19 = *arg0.add(48).cast::<usize>();
                        let len20 = l19;

                        _rt::Vec::from_raw_parts(l18.cast(), len20, len20)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                },
                pedersen_commit: _rt::Vec::from_raw_parts(l21.cast(), len23, len23),
                public_key: _rt::Vec::from_raw_parts(l24.cast(), len26, len26),
                response: _rt::Vec::from_raw_parts(l27.cast(), len29, len29),
                damgard: super::super::super::super::delano::wallet::types::DamgardTransformCompressed{
                  pedersen: super::super::super::super::delano::wallet::types::PedersenCompressed{
                    h: _rt::Vec::from_raw_parts(l30.cast(), len32, len32),
                  },
                },
              },
              nonce: match l33 {
                0 => None,
                1 => {
                  let e = {
                    let l34 = *arg0.add(88).cast::<*mut u8>();
                    let l35 = *arg0.add(92).cast::<usize>();
                    let len36 = l35;

                    _rt::Vec::from_raw_parts(l34.cast(), len36, len36)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
            }
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      });
      _rt::cabi_dealloc(arg0, 96, 4);
      let ptr38 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
      match result37 {
        Ok(e) => { {
          *ptr38.add(0).cast::<u8>() = (0i32) as u8;
          let super::super::super::super::delano::wallet::types::CredentialCompressed{ sigma:sigma39, update_key:update_key39, commitment_vector:commitment_vector39, opening_vector:opening_vector39, issuer_public:issuer_public39, } = e;
          let super::super::super::super::delano::wallet::types::SignatureCompressed{ z:z40, y_g1:y_g140, y_hat:y_hat40, t:t40, } = sigma39;
          let vec41 = (z40).into_boxed_slice();
          let ptr41 = vec41.as_ptr().cast::<u8>();
          let len41 = vec41.len();
          ::core::mem::forget(vec41);
          *ptr38.add(8).cast::<usize>() = len41;
          *ptr38.add(4).cast::<*mut u8>() = ptr41.cast_mut();
          let vec42 = (y_g140).into_boxed_slice();
          let ptr42 = vec42.as_ptr().cast::<u8>();
          let len42 = vec42.len();
          ::core::mem::forget(vec42);
          *ptr38.add(16).cast::<usize>() = len42;
          *ptr38.add(12).cast::<*mut u8>() = ptr42.cast_mut();
          let vec43 = (y_hat40).into_boxed_slice();
          let ptr43 = vec43.as_ptr().cast::<u8>();
          let len43 = vec43.len();
          ::core::mem::forget(vec43);
          *ptr38.add(24).cast::<usize>() = len43;
          *ptr38.add(20).cast::<*mut u8>() = ptr43.cast_mut();
          let vec44 = (t40).into_boxed_slice();
          let ptr44 = vec44.as_ptr().cast::<u8>();
          let len44 = vec44.len();
          ::core::mem::forget(vec44);
          *ptr38.add(32).cast::<usize>() = len44;
          *ptr38.add(28).cast::<*mut u8>() = ptr44.cast_mut();
          match update_key39 {
            Some(e) => {
              *ptr38.add(36).cast::<u8>() = (1i32) as u8;
              let vec47 = e;
              let len47 = vec47.len();
              let layout47 = _rt::alloc::Layout::from_size_align_unchecked(vec47.len() * 8, 4);
              let result47 = if layout47.size() != 0 {
                let ptr = _rt::alloc::alloc(layout47).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout47);
                }
                ptr
              }else {
                ::core::ptr::null_mut()
              };
              for (i, e) in vec47.into_iter().enumerate() {
                let base = result47.add(i * 8);
                {
                  let vec46 = e;
                  let len46 = vec46.len();
                  let layout46 = _rt::alloc::Layout::from_size_align_unchecked(vec46.len() * 8, 4);
                  let result46 = if layout46.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout46).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout46);
                    }
                    ptr
                  }else {
                    ::core::ptr::null_mut()
                  };
                  for (i, e) in vec46.into_iter().enumerate() {
                    let base = result46.add(i * 8);
                    {
                      let vec45 = (e).into_boxed_slice();
                      let ptr45 = vec45.as_ptr().cast::<u8>();
                      let len45 = vec45.len();
                      ::core::mem::forget(vec45);
                      *base.add(4).cast::<usize>() = len45;
                      *base.add(0).cast::<*mut u8>() = ptr45.cast_mut();
                    }
                  }
                  *base.add(4).cast::<usize>() = len46;
                  *base.add(0).cast::<*mut u8>() = result46;
                }
              }
              *ptr38.add(44).cast::<usize>() = len47;
              *ptr38.add(40).cast::<*mut u8>() = result47;
            },
            None => {
              {
                *ptr38.add(36).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec49 = commitment_vector39;
          let len49 = vec49.len();
          let layout49 = _rt::alloc::Layout::from_size_align_unchecked(vec49.len() * 8, 4);
          let result49 = if layout49.size() != 0 {
            let ptr = _rt::alloc::alloc(layout49).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout49);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec49.into_iter().enumerate() {
            let base = result49.add(i * 8);
            {
              let vec48 = (e).into_boxed_slice();
              let ptr48 = vec48.as_ptr().cast::<u8>();
              let len48 = vec48.len();
              ::core::mem::forget(vec48);
              *base.add(4).cast::<usize>() = len48;
              *base.add(0).cast::<*mut u8>() = ptr48.cast_mut();
            }
          }
          *ptr38.add(52).cast::<usize>() = len49;
          *ptr38.add(48).cast::<*mut u8>() = result49;
          let vec51 = opening_vector39;
          let len51 = vec51.len();
          let layout51 = _rt::alloc::Layout::from_size_align_unchecked(vec51.len() * 8, 4);
          let result51 = if layout51.size() != 0 {
            let ptr = _rt::alloc::alloc(layout51).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout51);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec51.into_iter().enumerate() {
            let base = result51.add(i * 8);
            {
              let vec50 = (e).into_boxed_slice();
              let ptr50 = vec50.as_ptr().cast::<u8>();
              let len50 = vec50.len();
              ::core::mem::forget(vec50);
              *base.add(4).cast::<usize>() = len50;
              *base.add(0).cast::<*mut u8>() = ptr50.cast_mut();
            }
          }
          *ptr38.add(60).cast::<usize>() = len51;
          *ptr38.add(56).cast::<*mut u8>() = result51;
          let super::super::super::super::delano::wallet::types::IssuerPublicCompressed{ parameters:parameters52, vk:vk52, } = issuer_public39;
          let super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{ pp_commit_g1:pp_commit_g153, pp_commit_g2:pp_commit_g253, } = parameters52;
          let vec55 = pp_commit_g153;
          let len55 = vec55.len();
          let layout55 = _rt::alloc::Layout::from_size_align_unchecked(vec55.len() * 8, 4);
          let result55 = if layout55.size() != 0 {
            let ptr = _rt::alloc::alloc(layout55).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout55);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec55.into_iter().enumerate() {
            let base = result55.add(i * 8);
            {
              let vec54 = (e).into_boxed_slice();
              let ptr54 = vec54.as_ptr().cast::<u8>();
              let len54 = vec54.len();
              ::core::mem::forget(vec54);
              *base.add(4).cast::<usize>() = len54;
              *base.add(0).cast::<*mut u8>() = ptr54.cast_mut();
            }
          }
          *ptr38.add(68).cast::<usize>() = len55;
          *ptr38.add(64).cast::<*mut u8>() = result55;
          let vec57 = pp_commit_g253;
          let len57 = vec57.len();
          let layout57 = _rt::alloc::Layout::from_size_align_unchecked(vec57.len() * 8, 4);
          let result57 = if layout57.size() != 0 {
            let ptr = _rt::alloc::alloc(layout57).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout57);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec57.into_iter().enumerate() {
            let base = result57.add(i * 8);
            {
              let vec56 = (e).into_boxed_slice();
              let ptr56 = vec56.as_ptr().cast::<u8>();
              let len56 = vec56.len();
              ::core::mem::forget(vec56);
              *base.add(4).cast::<usize>() = len56;
              *base.add(0).cast::<*mut u8>() = ptr56.cast_mut();
            }
          }
          *ptr38.add(76).cast::<usize>() = len57;
          *ptr38.add(72).cast::<*mut u8>() = result57;
          let vec61 = vk52;
          let len61 = vec61.len();
          let layout61 = _rt::alloc::Layout::from_size_align_unchecked(vec61.len() * 12, 4);
          let result61 = if layout61.size() != 0 {
            let ptr = _rt::alloc::alloc(layout61).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout61);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec61.into_iter().enumerate() {
            let base = result61.add(i * 12);
            {
              use super::super::super::super::delano::wallet::types::VkCompressed as V60;
              match e {
                V60::G1(e) => {
                  *base.add(0).cast::<u8>() = (0i32) as u8;
                  let vec58 = (e).into_boxed_slice();
                  let ptr58 = vec58.as_ptr().cast::<u8>();
                  let len58 = vec58.len();
                  ::core::mem::forget(vec58);
                  *base.add(8).cast::<usize>() = len58;
                  *base.add(4).cast::<*mut u8>() = ptr58.cast_mut();
                },
                V60::G2(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  let vec59 = (e).into_boxed_slice();
                  let ptr59 = vec59.as_ptr().cast::<u8>();
                  let len59 = vec59.len();
                  ::core::mem::forget(vec59);
                  *base.add(8).cast::<usize>() = len59;
                  *base.add(4).cast::<*mut u8>() = ptr59.cast_mut();
                },
              }
            }
          }
          *ptr38.add(84).cast::<usize>() = len61;
          *ptr38.add(80).cast::<*mut u8>() = result61;
        } },
        Err(e) => { {
          *ptr38.add(0).cast::<u8>() = (1i32) as u8;
          let vec62 = (e.into_bytes()).into_boxed_slice();
          let ptr62 = vec62.as_ptr().cast::<u8>();
          let len62 = vec62.len();
          ::core::mem::forget(vec62);
          *ptr38.add(8).cast::<usize>() = len62;
          *ptr38.add(4).cast::<*mut u8>() = ptr62.cast_mut();
        } },
      };ptr38
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn __post_return_issue<T: Guest>(arg0: *mut u8,) {
      let l0 = i32::from(*arg0.add(0).cast::<u8>());
      match l0 {
        0 => {
          let l1 = *arg0.add(4).cast::<*mut u8>();
          let l2 = *arg0.add(8).cast::<usize>();
          let base3 = l1;
          let len3 = l2;
          _rt::cabi_dealloc(base3, len3 * 1, 1);
          let l4 = *arg0.add(12).cast::<*mut u8>();
          let l5 = *arg0.add(16).cast::<usize>();
          let base6 = l4;
          let len6 = l5;
          _rt::cabi_dealloc(base6, len6 * 1, 1);
          let l7 = *arg0.add(20).cast::<*mut u8>();
          let l8 = *arg0.add(24).cast::<usize>();
          let base9 = l7;
          let len9 = l8;
          _rt::cabi_dealloc(base9, len9 * 1, 1);
          let l10 = *arg0.add(28).cast::<*mut u8>();
          let l11 = *arg0.add(32).cast::<usize>();
          let base12 = l10;
          let len12 = l11;
          _rt::cabi_dealloc(base12, len12 * 1, 1);
          let l13 = i32::from(*arg0.add(36).cast::<u8>());
          match l13 {
            0 => (),
            _ => {
              let l14 = *arg0.add(40).cast::<*mut u8>();
              let l15 = *arg0.add(44).cast::<usize>();
              let base22 = l14;
              let len22 = l15;
              for i in 0..len22 {
                let base = base22.add(i * 8);
                {
                  let l16 = *base.add(0).cast::<*mut u8>();
                  let l17 = *base.add(4).cast::<usize>();
                  let base21 = l16;
                  let len21 = l17;
                  for i in 0..len21 {
                    let base = base21.add(i * 8);
                    {
                      let l18 = *base.add(0).cast::<*mut u8>();
                      let l19 = *base.add(4).cast::<usize>();
                      let base20 = l18;
                      let len20 = l19;
                      _rt::cabi_dealloc(base20, len20 * 1, 1);
                    }
                  }
                  _rt::cabi_dealloc(base21, len21 * 8, 4);
                }
              }
              _rt::cabi_dealloc(base22, len22 * 8, 4);
            },
          }
          let l23 = *arg0.add(48).cast::<*mut u8>();
          let l24 = *arg0.add(52).cast::<usize>();
          let base28 = l23;
          let len28 = l24;
          for i in 0..len28 {
            let base = base28.add(i * 8);
            {
              let l25 = *base.add(0).cast::<*mut u8>();
              let l26 = *base.add(4).cast::<usize>();
              let base27 = l25;
              let len27 = l26;
              _rt::cabi_dealloc(base27, len27 * 1, 1);
            }
          }
          _rt::cabi_dealloc(base28, len28 * 8, 4);
          let l29 = *arg0.add(56).cast::<*mut u8>();
          let l30 = *arg0.add(60).cast::<usize>();
          let base34 = l29;
          let len34 = l30;
          for i in 0..len34 {
            let base = base34.add(i * 8);
            {
              let l31 = *base.add(0).cast::<*mut u8>();
              let l32 = *base.add(4).cast::<usize>();
              let base33 = l31;
              let len33 = l32;
              _rt::cabi_dealloc(base33, len33 * 1, 1);
            }
          }
          _rt::cabi_dealloc(base34, len34 * 8, 4);
          let l35 = *arg0.add(64).cast::<*mut u8>();
          let l36 = *arg0.add(68).cast::<usize>();
          let base40 = l35;
          let len40 = l36;
          for i in 0..len40 {
            let base = base40.add(i * 8);
            {
              let l37 = *base.add(0).cast::<*mut u8>();
              let l38 = *base.add(4).cast::<usize>();
              let base39 = l37;
              let len39 = l38;
              _rt::cabi_dealloc(base39, len39 * 1, 1);
            }
          }
          _rt::cabi_dealloc(base40, len40 * 8, 4);
          let l41 = *arg0.add(72).cast::<*mut u8>();
          let l42 = *arg0.add(76).cast::<usize>();
          let base46 = l41;
          let len46 = l42;
          for i in 0..len46 {
            let base = base46.add(i * 8);
            {
              let l43 = *base.add(0).cast::<*mut u8>();
              let l44 = *base.add(4).cast::<usize>();
              let base45 = l43;
              let len45 = l44;
              _rt::cabi_dealloc(base45, len45 * 1, 1);
            }
          }
          _rt::cabi_dealloc(base46, len46 * 8, 4);
          let l47 = *arg0.add(80).cast::<*mut u8>();
          let l48 = *arg0.add(84).cast::<usize>();
          let base56 = l47;
          let len56 = l48;
          for i in 0..len56 {
            let base = base56.add(i * 12);
            {
              let l49 = i32::from(*base.add(0).cast::<u8>());
              match l49 {
                0 => {
                  let l50 = *base.add(4).cast::<*mut u8>();
                  let l51 = *base.add(8).cast::<usize>();
                  let base52 = l50;
                  let len52 = l51;
                  _rt::cabi_dealloc(base52, len52 * 1, 1);
                },
                _ => {
                  let l53 = *base.add(4).cast::<*mut u8>();
                  let l54 = *base.add(8).cast::<usize>();
                  let base55 = l53;
                  let len55 = l54;
                  _rt::cabi_dealloc(base55, len55 * 1, 1);
                },
              }
            }
          }
          _rt::cabi_dealloc(base56, len56 * 12, 4);
        },
        _ => {
          let l57 = *arg0.add(4).cast::<*mut u8>();
          let l58 = *arg0.add(8).cast::<usize>();
          _rt::cabi_dealloc(l57, l58, 1);
        },
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_offer_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(4).cast::<usize>();
    let len2 = l1;
    let l3 = *arg0.add(8).cast::<*mut u8>();
    let l4 = *arg0.add(12).cast::<usize>();
    let len5 = l4;
    let l6 = *arg0.add(16).cast::<*mut u8>();
    let l7 = *arg0.add(20).cast::<usize>();
    let len8 = l7;
    let l9 = *arg0.add(24).cast::<*mut u8>();
    let l10 = *arg0.add(28).cast::<usize>();
    let len11 = l10;
    let l12 = i32::from(*arg0.add(32).cast::<u8>());
    let l22 = *arg0.add(44).cast::<*mut u8>();
    let l23 = *arg0.add(48).cast::<usize>();
    let base27 = l22;
    let len27 = l23;
    let mut result27 = _rt::Vec::with_capacity(len27);
    for i in 0..len27 {
      let base = base27.add(i * 8);
      let e27 = {
        let l24 = *base.add(0).cast::<*mut u8>();
        let l25 = *base.add(4).cast::<usize>();
        let len26 = l25;

        _rt::Vec::from_raw_parts(l24.cast(), len26, len26)
      };
      result27.push(e27);
    }
    _rt::cabi_dealloc(base27, len27 * 8, 4);
    let l28 = *arg0.add(52).cast::<*mut u8>();
    let l29 = *arg0.add(56).cast::<usize>();
    let base33 = l28;
    let len33 = l29;
    let mut result33 = _rt::Vec::with_capacity(len33);
    for i in 0..len33 {
      let base = base33.add(i * 8);
      let e33 = {
        let l30 = *base.add(0).cast::<*mut u8>();
        let l31 = *base.add(4).cast::<usize>();
        let len32 = l31;

        _rt::Vec::from_raw_parts(l30.cast(), len32, len32)
      };
      result33.push(e33);
    }
    _rt::cabi_dealloc(base33, len33 * 8, 4);
    let l34 = *arg0.add(60).cast::<*mut u8>();
    let l35 = *arg0.add(64).cast::<usize>();
    let base39 = l34;
    let len39 = l35;
    let mut result39 = _rt::Vec::with_capacity(len39);
    for i in 0..len39 {
      let base = base39.add(i * 8);
      let e39 = {
        let l36 = *base.add(0).cast::<*mut u8>();
        let l37 = *base.add(4).cast::<usize>();
        let len38 = l37;

        _rt::Vec::from_raw_parts(l36.cast(), len38, len38)
      };
      result39.push(e39);
    }
    _rt::cabi_dealloc(base39, len39 * 8, 4);
    let l40 = *arg0.add(68).cast::<*mut u8>();
    let l41 = *arg0.add(72).cast::<usize>();
    let base45 = l40;
    let len45 = l41;
    let mut result45 = _rt::Vec::with_capacity(len45);
    for i in 0..len45 {
      let base = base45.add(i * 8);
      let e45 = {
        let l42 = *base.add(0).cast::<*mut u8>();
        let l43 = *base.add(4).cast::<usize>();
        let len44 = l43;

        _rt::Vec::from_raw_parts(l42.cast(), len44, len44)
      };
      result45.push(e45);
    }
    _rt::cabi_dealloc(base45, len45 * 8, 4);
    let l46 = *arg0.add(76).cast::<*mut u8>();
    let l47 = *arg0.add(80).cast::<usize>();
    let base56 = l46;
    let len56 = l47;
    let mut result56 = _rt::Vec::with_capacity(len56);
    for i in 0..len56 {
      let base = base56.add(i * 12);
      let e56 = {
        let l48 = i32::from(*base.add(0).cast::<u8>());
        use super::super::super::super::delano::wallet::types::VkCompressed as V55;
        let v55 = match l48 {
          0 => {
            let e55 = {
              let l49 = *base.add(4).cast::<*mut u8>();
              let l50 = *base.add(8).cast::<usize>();
              let len51 = l50;

              _rt::Vec::from_raw_parts(l49.cast(), len51, len51)
            };
            V55::G1(e55)
          }
          n => {
            debug_assert_eq!(n, 1, "invalid enum discriminant");
            let e55 = {
              let l52 = *base.add(4).cast::<*mut u8>();
              let l53 = *base.add(8).cast::<usize>();
              let len54 = l53;

              _rt::Vec::from_raw_parts(l52.cast(), len54, len54)
            };
            V55::G2(e55)
          }
        };

        v55
      };
      result56.push(e56);
    }
    _rt::cabi_dealloc(base56, len56 * 12, 4);
    let l57 = i32::from(*arg0.add(84).cast::<u8>());
    let l73 = i32::from(*arg0.add(104).cast::<u8>());
    let l80 = i32::from(*arg0.add(116).cast::<u8>());
    let result82 = T::offer(super::super::super::super::delano::wallet::types::CredentialCompressed{
      sigma: super::super::super::super::delano::wallet::types::SignatureCompressed{
        z: _rt::Vec::from_raw_parts(l0.cast(), len2, len2),
        y_g1: _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
        y_hat: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
        t: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
      },
      update_key: match l12 {
        0 => None,
        1 => {
          let e = {
            let l13 = *arg0.add(36).cast::<*mut u8>();
            let l14 = *arg0.add(40).cast::<usize>();
            let base21 = l13;
            let len21 = l14;
            let mut result21 = _rt::Vec::with_capacity(len21);
            for i in 0..len21 {
              let base = base21.add(i * 8);
              let e21 = {
                let l15 = *base.add(0).cast::<*mut u8>();
                let l16 = *base.add(4).cast::<usize>();
                let base20 = l15;
                let len20 = l16;
                let mut result20 = _rt::Vec::with_capacity(len20);
                for i in 0..len20 {
                  let base = base20.add(i * 8);
                  let e20 = {
                    let l17 = *base.add(0).cast::<*mut u8>();
                    let l18 = *base.add(4).cast::<usize>();
                    let len19 = l18;

                    _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                  };
                  result20.push(e20);
                }
                _rt::cabi_dealloc(base20, len20 * 8, 4);

                result20
              };
              result21.push(e21);
            }
            _rt::cabi_dealloc(base21, len21 * 8, 4);

            result21
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      },
      commitment_vector: result27,
      opening_vector: result33,
      issuer_public: super::super::super::super::delano::wallet::types::IssuerPublicCompressed{
        parameters: super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{
          pp_commit_g1: result39,
          pp_commit_g2: result45,
        },
        vk: result56,
      },
    }, super::super::super::super::delano::wallet::types::OfferConfig{
      redact: match l57 {
        0 => None,
        1 => {
          let e = {
            let l58 = *arg0.add(88).cast::<*mut u8>();
            let l59 = *arg0.add(92).cast::<usize>();
            let base66 = l58;
            let len66 = l59;
            let mut result66 = _rt::Vec::with_capacity(len66);
            for i in 0..len66 {
              let base = base66.add(i * 8);
              let e66 = {
                let l60 = *base.add(0).cast::<*mut u8>();
                let l61 = *base.add(4).cast::<usize>();
                let base65 = l60;
                let len65 = l61;
                let mut result65 = _rt::Vec::with_capacity(len65);
                for i in 0..len65 {
                  let base = base65.add(i * 8);
                  let e65 = {
                    let l62 = *base.add(0).cast::<*mut u8>();
                    let l63 = *base.add(4).cast::<usize>();
                    let len64 = l63;

                    _rt::Vec::from_raw_parts(l62.cast(), len64, len64)
                  };
                  result65.push(e65);
                }
                _rt::cabi_dealloc(base65, len65 * 8, 4);

                result65
              };
              result66.push(e66);
            }
            _rt::cabi_dealloc(base66, len66 * 8, 4);
            let l67 = *arg0.add(96).cast::<*mut u8>();
            let l68 = *arg0.add(100).cast::<usize>();
            let base72 = l67;
            let len72 = l68;
            let mut result72 = _rt::Vec::with_capacity(len72);
            for i in 0..len72 {
              let base = base72.add(i * 8);
              let e72 = {
                let l69 = *base.add(0).cast::<*mut u8>();
                let l70 = *base.add(4).cast::<usize>();
                let len71 = l70;

                _rt::Vec::from_raw_parts(l69.cast(), len71, len71)
              };
              result72.push(e72);
            }
            _rt::cabi_dealloc(base72, len72 * 8, 4);

            super::super::super::super::delano::wallet::types::Redactables{
              entries: result66,
              remove: result72,
            }
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      },
      additional_entry: match l73 {
        0 => None,
        1 => {
          let e = {
            let l74 = *arg0.add(108).cast::<*mut u8>();
            let l75 = *arg0.add(112).cast::<usize>();
            let base79 = l74;
            let len79 = l75;
            let mut result79 = _rt::Vec::with_capacity(len79);
            for i in 0..len79 {
              let base = base79.add(i * 8);
              let e79 = {
                let l76 = *base.add(0).cast::<*mut u8>();
                let l77 = *base.add(4).cast::<usize>();
                let len78 = l77;

                _rt::Vec::from_raw_parts(l76.cast(), len78, len78)
              };
              result79.push(e79);
            }
            _rt::cabi_dealloc(base79, len79 * 8, 4);

            result79
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      },
      max_entries: match l80 {
        0 => None,
        1 => {
          let e = {
            let l81 = i32::from(*arg0.add(117).cast::<u8>());

            l81 as u8
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      },
    });
    _rt::cabi_dealloc(arg0, 120, 4);
    let ptr83 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result82 {
      Ok(e) => { {
        *ptr83.add(0).cast::<u8>() = (0i32) as u8;
        let super::super::super::super::delano::wallet::types::CredentialCompressed{ sigma:sigma84, update_key:update_key84, commitment_vector:commitment_vector84, opening_vector:opening_vector84, issuer_public:issuer_public84, } = e;
        let super::super::super::super::delano::wallet::types::SignatureCompressed{ z:z85, y_g1:y_g185, y_hat:y_hat85, t:t85, } = sigma84;
        let vec86 = (z85).into_boxed_slice();
        let ptr86 = vec86.as_ptr().cast::<u8>();
        let len86 = vec86.len();
        ::core::mem::forget(vec86);
        *ptr83.add(8).cast::<usize>() = len86;
        *ptr83.add(4).cast::<*mut u8>() = ptr86.cast_mut();
        let vec87 = (y_g185).into_boxed_slice();
        let ptr87 = vec87.as_ptr().cast::<u8>();
        let len87 = vec87.len();
        ::core::mem::forget(vec87);
        *ptr83.add(16).cast::<usize>() = len87;
        *ptr83.add(12).cast::<*mut u8>() = ptr87.cast_mut();
        let vec88 = (y_hat85).into_boxed_slice();
        let ptr88 = vec88.as_ptr().cast::<u8>();
        let len88 = vec88.len();
        ::core::mem::forget(vec88);
        *ptr83.add(24).cast::<usize>() = len88;
        *ptr83.add(20).cast::<*mut u8>() = ptr88.cast_mut();
        let vec89 = (t85).into_boxed_slice();
        let ptr89 = vec89.as_ptr().cast::<u8>();
        let len89 = vec89.len();
        ::core::mem::forget(vec89);
        *ptr83.add(32).cast::<usize>() = len89;
        *ptr83.add(28).cast::<*mut u8>() = ptr89.cast_mut();
        match update_key84 {
          Some(e) => {
            *ptr83.add(36).cast::<u8>() = (1i32) as u8;
            let vec92 = e;
            let len92 = vec92.len();
            let layout92 = _rt::alloc::Layout::from_size_align_unchecked(vec92.len() * 8, 4);
            let result92 = if layout92.size() != 0 {
              let ptr = _rt::alloc::alloc(layout92).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout92);
              }
              ptr
            }else {
              ::core::ptr::null_mut()
            };
            for (i, e) in vec92.into_iter().enumerate() {
              let base = result92.add(i * 8);
              {
                let vec91 = e;
                let len91 = vec91.len();
                let layout91 = _rt::alloc::Layout::from_size_align_unchecked(vec91.len() * 8, 4);
                let result91 = if layout91.size() != 0 {
                  let ptr = _rt::alloc::alloc(layout91).cast::<u8>();
                  if ptr.is_null()
                  {
                    _rt::alloc::handle_alloc_error(layout91);
                  }
                  ptr
                }else {
                  ::core::ptr::null_mut()
                };
                for (i, e) in vec91.into_iter().enumerate() {
                  let base = result91.add(i * 8);
                  {
                    let vec90 = (e).into_boxed_slice();
                    let ptr90 = vec90.as_ptr().cast::<u8>();
                    let len90 = vec90.len();
                    ::core::mem::forget(vec90);
                    *base.add(4).cast::<usize>() = len90;
                    *base.add(0).cast::<*mut u8>() = ptr90.cast_mut();
                  }
                }
                *base.add(4).cast::<usize>() = len91;
                *base.add(0).cast::<*mut u8>() = result91;
              }
            }
            *ptr83.add(44).cast::<usize>() = len92;
            *ptr83.add(40).cast::<*mut u8>() = result92;
          },
          None => {
            {
              *ptr83.add(36).cast::<u8>() = (0i32) as u8;
            }
          },
        };let vec94 = commitment_vector84;
        let len94 = vec94.len();
        let layout94 = _rt::alloc::Layout::from_size_align_unchecked(vec94.len() * 8, 4);
        let result94 = if layout94.size() != 0 {
          let ptr = _rt::alloc::alloc(layout94).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout94);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec94.into_iter().enumerate() {
          let base = result94.add(i * 8);
          {
            let vec93 = (e).into_boxed_slice();
            let ptr93 = vec93.as_ptr().cast::<u8>();
            let len93 = vec93.len();
            ::core::mem::forget(vec93);
            *base.add(4).cast::<usize>() = len93;
            *base.add(0).cast::<*mut u8>() = ptr93.cast_mut();
          }
        }
        *ptr83.add(52).cast::<usize>() = len94;
        *ptr83.add(48).cast::<*mut u8>() = result94;
        let vec96 = opening_vector84;
        let len96 = vec96.len();
        let layout96 = _rt::alloc::Layout::from_size_align_unchecked(vec96.len() * 8, 4);
        let result96 = if layout96.size() != 0 {
          let ptr = _rt::alloc::alloc(layout96).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout96);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec96.into_iter().enumerate() {
          let base = result96.add(i * 8);
          {
            let vec95 = (e).into_boxed_slice();
            let ptr95 = vec95.as_ptr().cast::<u8>();
            let len95 = vec95.len();
            ::core::mem::forget(vec95);
            *base.add(4).cast::<usize>() = len95;
            *base.add(0).cast::<*mut u8>() = ptr95.cast_mut();
          }
        }
        *ptr83.add(60).cast::<usize>() = len96;
        *ptr83.add(56).cast::<*mut u8>() = result96;
        let super::super::super::super::delano::wallet::types::IssuerPublicCompressed{ parameters:parameters97, vk:vk97, } = issuer_public84;
        let super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{ pp_commit_g1:pp_commit_g198, pp_commit_g2:pp_commit_g298, } = parameters97;
        let vec100 = pp_commit_g198;
        let len100 = vec100.len();
        let layout100 = _rt::alloc::Layout::from_size_align_unchecked(vec100.len() * 8, 4);
        let result100 = if layout100.size() != 0 {
          let ptr = _rt::alloc::alloc(layout100).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout100);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec100.into_iter().enumerate() {
          let base = result100.add(i * 8);
          {
            let vec99 = (e).into_boxed_slice();
            let ptr99 = vec99.as_ptr().cast::<u8>();
            let len99 = vec99.len();
            ::core::mem::forget(vec99);
            *base.add(4).cast::<usize>() = len99;
            *base.add(0).cast::<*mut u8>() = ptr99.cast_mut();
          }
        }
        *ptr83.add(68).cast::<usize>() = len100;
        *ptr83.add(64).cast::<*mut u8>() = result100;
        let vec102 = pp_commit_g298;
        let len102 = vec102.len();
        let layout102 = _rt::alloc::Layout::from_size_align_unchecked(vec102.len() * 8, 4);
        let result102 = if layout102.size() != 0 {
          let ptr = _rt::alloc::alloc(layout102).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout102);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec102.into_iter().enumerate() {
          let base = result102.add(i * 8);
          {
            let vec101 = (e).into_boxed_slice();
            let ptr101 = vec101.as_ptr().cast::<u8>();
            let len101 = vec101.len();
            ::core::mem::forget(vec101);
            *base.add(4).cast::<usize>() = len101;
            *base.add(0).cast::<*mut u8>() = ptr101.cast_mut();
          }
        }
        *ptr83.add(76).cast::<usize>() = len102;
        *ptr83.add(72).cast::<*mut u8>() = result102;
        let vec106 = vk97;
        let len106 = vec106.len();
        let layout106 = _rt::alloc::Layout::from_size_align_unchecked(vec106.len() * 12, 4);
        let result106 = if layout106.size() != 0 {
          let ptr = _rt::alloc::alloc(layout106).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout106);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec106.into_iter().enumerate() {
          let base = result106.add(i * 12);
          {
            use super::super::super::super::delano::wallet::types::VkCompressed as V105;
            match e {
              V105::G1(e) => {
                *base.add(0).cast::<u8>() = (0i32) as u8;
                let vec103 = (e).into_boxed_slice();
                let ptr103 = vec103.as_ptr().cast::<u8>();
                let len103 = vec103.len();
                ::core::mem::forget(vec103);
                *base.add(8).cast::<usize>() = len103;
                *base.add(4).cast::<*mut u8>() = ptr103.cast_mut();
              },
              V105::G2(e) => {
                *base.add(0).cast::<u8>() = (1i32) as u8;
                let vec104 = (e).into_boxed_slice();
                let ptr104 = vec104.as_ptr().cast::<u8>();
                let len104 = vec104.len();
                ::core::mem::forget(vec104);
                *base.add(8).cast::<usize>() = len104;
                *base.add(4).cast::<*mut u8>() = ptr104.cast_mut();
              },
            }
          }
        }
        *ptr83.add(84).cast::<usize>() = len106;
        *ptr83.add(80).cast::<*mut u8>() = result106;
      } },
      Err(e) => { {
        *ptr83.add(0).cast::<u8>() = (1i32) as u8;
        let vec107 = (e.into_bytes()).into_boxed_slice();
        let ptr107 = vec107.as_ptr().cast::<u8>();
        let len107 = vec107.len();
        ::core::mem::forget(vec107);
        *ptr83.add(8).cast::<usize>() = len107;
        *ptr83.add(4).cast::<*mut u8>() = ptr107.cast_mut();
      } },
    };ptr83
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_offer<T: Guest>(arg0: *mut u8,) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => {
        let l1 = *arg0.add(4).cast::<*mut u8>();
        let l2 = *arg0.add(8).cast::<usize>();
        let base3 = l1;
        let len3 = l2;
        _rt::cabi_dealloc(base3, len3 * 1, 1);
        let l4 = *arg0.add(12).cast::<*mut u8>();
        let l5 = *arg0.add(16).cast::<usize>();
        let base6 = l4;
        let len6 = l5;
        _rt::cabi_dealloc(base6, len6 * 1, 1);
        let l7 = *arg0.add(20).cast::<*mut u8>();
        let l8 = *arg0.add(24).cast::<usize>();
        let base9 = l7;
        let len9 = l8;
        _rt::cabi_dealloc(base9, len9 * 1, 1);
        let l10 = *arg0.add(28).cast::<*mut u8>();
        let l11 = *arg0.add(32).cast::<usize>();
        let base12 = l10;
        let len12 = l11;
        _rt::cabi_dealloc(base12, len12 * 1, 1);
        let l13 = i32::from(*arg0.add(36).cast::<u8>());
        match l13 {
          0 => (),
          _ => {
            let l14 = *arg0.add(40).cast::<*mut u8>();
            let l15 = *arg0.add(44).cast::<usize>();
            let base22 = l14;
            let len22 = l15;
            for i in 0..len22 {
              let base = base22.add(i * 8);
              {
                let l16 = *base.add(0).cast::<*mut u8>();
                let l17 = *base.add(4).cast::<usize>();
                let base21 = l16;
                let len21 = l17;
                for i in 0..len21 {
                  let base = base21.add(i * 8);
                  {
                    let l18 = *base.add(0).cast::<*mut u8>();
                    let l19 = *base.add(4).cast::<usize>();
                    let base20 = l18;
                    let len20 = l19;
                    _rt::cabi_dealloc(base20, len20 * 1, 1);
                  }
                }
                _rt::cabi_dealloc(base21, len21 * 8, 4);
              }
            }
            _rt::cabi_dealloc(base22, len22 * 8, 4);
          },
        }
        let l23 = *arg0.add(48).cast::<*mut u8>();
        let l24 = *arg0.add(52).cast::<usize>();
        let base28 = l23;
        let len28 = l24;
        for i in 0..len28 {
          let base = base28.add(i * 8);
          {
            let l25 = *base.add(0).cast::<*mut u8>();
            let l26 = *base.add(4).cast::<usize>();
            let base27 = l25;
            let len27 = l26;
            _rt::cabi_dealloc(base27, len27 * 1, 1);
          }
        }
        _rt::cabi_dealloc(base28, len28 * 8, 4);
        let l29 = *arg0.add(56).cast::<*mut u8>();
        let l30 = *arg0.add(60).cast::<usize>();
        let base34 = l29;
        let len34 = l30;
        for i in 0..len34 {
          let base = base34.add(i * 8);
          {
            let l31 = *base.add(0).cast::<*mut u8>();
            let l32 = *base.add(4).cast::<usize>();
            let base33 = l31;
            let len33 = l32;
            _rt::cabi_dealloc(base33, len33 * 1, 1);
          }
        }
        _rt::cabi_dealloc(base34, len34 * 8, 4);
        let l35 = *arg0.add(64).cast::<*mut u8>();
        let l36 = *arg0.add(68).cast::<usize>();
        let base40 = l35;
        let len40 = l36;
        for i in 0..len40 {
          let base = base40.add(i * 8);
          {
            let l37 = *base.add(0).cast::<*mut u8>();
            let l38 = *base.add(4).cast::<usize>();
            let base39 = l37;
            let len39 = l38;
            _rt::cabi_dealloc(base39, len39 * 1, 1);
          }
        }
        _rt::cabi_dealloc(base40, len40 * 8, 4);
        let l41 = *arg0.add(72).cast::<*mut u8>();
        let l42 = *arg0.add(76).cast::<usize>();
        let base46 = l41;
        let len46 = l42;
        for i in 0..len46 {
          let base = base46.add(i * 8);
          {
            let l43 = *base.add(0).cast::<*mut u8>();
            let l44 = *base.add(4).cast::<usize>();
            let base45 = l43;
            let len45 = l44;
            _rt::cabi_dealloc(base45, len45 * 1, 1);
          }
        }
        _rt::cabi_dealloc(base46, len46 * 8, 4);
        let l47 = *arg0.add(80).cast::<*mut u8>();
        let l48 = *arg0.add(84).cast::<usize>();
        let base56 = l47;
        let len56 = l48;
        for i in 0..len56 {
          let base = base56.add(i * 12);
          {
            let l49 = i32::from(*base.add(0).cast::<u8>());
            match l49 {
              0 => {
                let l50 = *base.add(4).cast::<*mut u8>();
                let l51 = *base.add(8).cast::<usize>();
                let base52 = l50;
                let len52 = l51;
                _rt::cabi_dealloc(base52, len52 * 1, 1);
              },
              _ => {
                let l53 = *base.add(4).cast::<*mut u8>();
                let l54 = *base.add(8).cast::<usize>();
                let base55 = l53;
                let len55 = l54;
                _rt::cabi_dealloc(base55, len55 * 1, 1);
              },
            }
          }
        }
        _rt::cabi_dealloc(base56, len56 * 12, 4);
      },
      _ => {
        let l57 = *arg0.add(4).cast::<*mut u8>();
        let l58 = *arg0.add(8).cast::<usize>();
        _rt::cabi_dealloc(l57, l58, 1);
      },
    }
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_accept_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(4).cast::<usize>();
  let len2 = l1;
  let l3 = *arg0.add(8).cast::<*mut u8>();
  let l4 = *arg0.add(12).cast::<usize>();
  let len5 = l4;
  let l6 = *arg0.add(16).cast::<*mut u8>();
  let l7 = *arg0.add(20).cast::<usize>();
  let len8 = l7;
  let l9 = *arg0.add(24).cast::<*mut u8>();
  let l10 = *arg0.add(28).cast::<usize>();
  let len11 = l10;
  let l12 = i32::from(*arg0.add(32).cast::<u8>());
  let l22 = *arg0.add(44).cast::<*mut u8>();
  let l23 = *arg0.add(48).cast::<usize>();
  let base27 = l22;
  let len27 = l23;
  let mut result27 = _rt::Vec::with_capacity(len27);
  for i in 0..len27 {
    let base = base27.add(i * 8);
    let e27 = {
      let l24 = *base.add(0).cast::<*mut u8>();
      let l25 = *base.add(4).cast::<usize>();
      let len26 = l25;

      _rt::Vec::from_raw_parts(l24.cast(), len26, len26)
    };
    result27.push(e27);
  }
  _rt::cabi_dealloc(base27, len27 * 8, 4);
  let l28 = *arg0.add(52).cast::<*mut u8>();
  let l29 = *arg0.add(56).cast::<usize>();
  let base33 = l28;
  let len33 = l29;
  let mut result33 = _rt::Vec::with_capacity(len33);
  for i in 0..len33 {
    let base = base33.add(i * 8);
    let e33 = {
      let l30 = *base.add(0).cast::<*mut u8>();
      let l31 = *base.add(4).cast::<usize>();
      let len32 = l31;

      _rt::Vec::from_raw_parts(l30.cast(), len32, len32)
    };
    result33.push(e33);
  }
  _rt::cabi_dealloc(base33, len33 * 8, 4);
  let l34 = *arg0.add(60).cast::<*mut u8>();
  let l35 = *arg0.add(64).cast::<usize>();
  let base39 = l34;
  let len39 = l35;
  let mut result39 = _rt::Vec::with_capacity(len39);
  for i in 0..len39 {
    let base = base39.add(i * 8);
    let e39 = {
      let l36 = *base.add(0).cast::<*mut u8>();
      let l37 = *base.add(4).cast::<usize>();
      let len38 = l37;

      _rt::Vec::from_raw_parts(l36.cast(), len38, len38)
    };
    result39.push(e39);
  }
  _rt::cabi_dealloc(base39, len39 * 8, 4);
  let l40 = *arg0.add(68).cast::<*mut u8>();
  let l41 = *arg0.add(72).cast::<usize>();
  let base45 = l40;
  let len45 = l41;
  let mut result45 = _rt::Vec::with_capacity(len45);
  for i in 0..len45 {
    let base = base45.add(i * 8);
    let e45 = {
      let l42 = *base.add(0).cast::<*mut u8>();
      let l43 = *base.add(4).cast::<usize>();
      let len44 = l43;

      _rt::Vec::from_raw_parts(l42.cast(), len44, len44)
    };
    result45.push(e45);
  }
  _rt::cabi_dealloc(base45, len45 * 8, 4);
  let l46 = *arg0.add(76).cast::<*mut u8>();
  let l47 = *arg0.add(80).cast::<usize>();
  let base56 = l46;
  let len56 = l47;
  let mut result56 = _rt::Vec::with_capacity(len56);
  for i in 0..len56 {
    let base = base56.add(i * 12);
    let e56 = {
      let l48 = i32::from(*base.add(0).cast::<u8>());
      use super::super::super::super::delano::wallet::types::VkCompressed as V55;
      let v55 = match l48 {
        0 => {
          let e55 = {
            let l49 = *base.add(4).cast::<*mut u8>();
            let l50 = *base.add(8).cast::<usize>();
            let len51 = l50;

            _rt::Vec::from_raw_parts(l49.cast(), len51, len51)
          };
          V55::G1(e55)
        }
        n => {
          debug_assert_eq!(n, 1, "invalid enum discriminant");
          let e55 = {
            let l52 = *base.add(4).cast::<*mut u8>();
            let l53 = *base.add(8).cast::<usize>();
            let len54 = l53;

            _rt::Vec::from_raw_parts(l52.cast(), len54, len54)
          };
          V55::G2(e55)
        }
      };

      v55
    };
    result56.push(e56);
  }
  _rt::cabi_dealloc(base56, len56 * 12, 4);
  let result57 = T::accept(super::super::super::super::delano::wallet::types::CredentialCompressed{
    sigma: super::super::super::super::delano::wallet::types::SignatureCompressed{
      z: _rt::Vec::from_raw_parts(l0.cast(), len2, len2),
      y_g1: _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
      y_hat: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
      t: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
    },
    update_key: match l12 {
      0 => None,
      1 => {
        let e = {
          let l13 = *arg0.add(36).cast::<*mut u8>();
          let l14 = *arg0.add(40).cast::<usize>();
          let base21 = l13;
          let len21 = l14;
          let mut result21 = _rt::Vec::with_capacity(len21);
          for i in 0..len21 {
            let base = base21.add(i * 8);
            let e21 = {
              let l15 = *base.add(0).cast::<*mut u8>();
              let l16 = *base.add(4).cast::<usize>();
              let base20 = l15;
              let len20 = l16;
              let mut result20 = _rt::Vec::with_capacity(len20);
              for i in 0..len20 {
                let base = base20.add(i * 8);
                let e20 = {
                  let l17 = *base.add(0).cast::<*mut u8>();
                  let l18 = *base.add(4).cast::<usize>();
                  let len19 = l18;

                  _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                };
                result20.push(e20);
              }
              _rt::cabi_dealloc(base20, len20 * 8, 4);

              result20
            };
            result21.push(e21);
          }
          _rt::cabi_dealloc(base21, len21 * 8, 4);

          result21
        };
        Some(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    },
    commitment_vector: result27,
    opening_vector: result33,
    issuer_public: super::super::super::super::delano::wallet::types::IssuerPublicCompressed{
      parameters: super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{
        pp_commit_g1: result39,
        pp_commit_g2: result45,
      },
      vk: result56,
    },
  });
  _rt::cabi_dealloc(arg0, 84, 4);
  let ptr58 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
  match result57 {
    Ok(e) => { {
      *ptr58.add(0).cast::<u8>() = (0i32) as u8;
      let super::super::super::super::delano::wallet::types::CredentialCompressed{ sigma:sigma59, update_key:update_key59, commitment_vector:commitment_vector59, opening_vector:opening_vector59, issuer_public:issuer_public59, } = e;
      let super::super::super::super::delano::wallet::types::SignatureCompressed{ z:z60, y_g1:y_g160, y_hat:y_hat60, t:t60, } = sigma59;
      let vec61 = (z60).into_boxed_slice();
      let ptr61 = vec61.as_ptr().cast::<u8>();
      let len61 = vec61.len();
      ::core::mem::forget(vec61);
      *ptr58.add(8).cast::<usize>() = len61;
      *ptr58.add(4).cast::<*mut u8>() = ptr61.cast_mut();
      let vec62 = (y_g160).into_boxed_slice();
      let ptr62 = vec62.as_ptr().cast::<u8>();
      let len62 = vec62.len();
      ::core::mem::forget(vec62);
      *ptr58.add(16).cast::<usize>() = len62;
      *ptr58.add(12).cast::<*mut u8>() = ptr62.cast_mut();
      let vec63 = (y_hat60).into_boxed_slice();
      let ptr63 = vec63.as_ptr().cast::<u8>();
      let len63 = vec63.len();
      ::core::mem::forget(vec63);
      *ptr58.add(24).cast::<usize>() = len63;
      *ptr58.add(20).cast::<*mut u8>() = ptr63.cast_mut();
      let vec64 = (t60).into_boxed_slice();
      let ptr64 = vec64.as_ptr().cast::<u8>();
      let len64 = vec64.len();
      ::core::mem::forget(vec64);
      *ptr58.add(32).cast::<usize>() = len64;
      *ptr58.add(28).cast::<*mut u8>() = ptr64.cast_mut();
      match update_key59 {
        Some(e) => {
          *ptr58.add(36).cast::<u8>() = (1i32) as u8;
          let vec67 = e;
          let len67 = vec67.len();
          let layout67 = _rt::alloc::Layout::from_size_align_unchecked(vec67.len() * 8, 4);
          let result67 = if layout67.size() != 0 {
            let ptr = _rt::alloc::alloc(layout67).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout67);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec67.into_iter().enumerate() {
            let base = result67.add(i * 8);
            {
              let vec66 = e;
              let len66 = vec66.len();
              let layout66 = _rt::alloc::Layout::from_size_align_unchecked(vec66.len() * 8, 4);
              let result66 = if layout66.size() != 0 {
                let ptr = _rt::alloc::alloc(layout66).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout66);
                }
                ptr
              }else {
                ::core::ptr::null_mut()
              };
              for (i, e) in vec66.into_iter().enumerate() {
                let base = result66.add(i * 8);
                {
                  let vec65 = (e).into_boxed_slice();
                  let ptr65 = vec65.as_ptr().cast::<u8>();
                  let len65 = vec65.len();
                  ::core::mem::forget(vec65);
                  *base.add(4).cast::<usize>() = len65;
                  *base.add(0).cast::<*mut u8>() = ptr65.cast_mut();
                }
              }
              *base.add(4).cast::<usize>() = len66;
              *base.add(0).cast::<*mut u8>() = result66;
            }
          }
          *ptr58.add(44).cast::<usize>() = len67;
          *ptr58.add(40).cast::<*mut u8>() = result67;
        },
        None => {
          {
            *ptr58.add(36).cast::<u8>() = (0i32) as u8;
          }
        },
      };let vec69 = commitment_vector59;
      let len69 = vec69.len();
      let layout69 = _rt::alloc::Layout::from_size_align_unchecked(vec69.len() * 8, 4);
      let result69 = if layout69.size() != 0 {
        let ptr = _rt::alloc::alloc(layout69).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout69);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec69.into_iter().enumerate() {
        let base = result69.add(i * 8);
        {
          let vec68 = (e).into_boxed_slice();
          let ptr68 = vec68.as_ptr().cast::<u8>();
          let len68 = vec68.len();
          ::core::mem::forget(vec68);
          *base.add(4).cast::<usize>() = len68;
          *base.add(0).cast::<*mut u8>() = ptr68.cast_mut();
        }
      }
      *ptr58.add(52).cast::<usize>() = len69;
      *ptr58.add(48).cast::<*mut u8>() = result69;
      let vec71 = opening_vector59;
      let len71 = vec71.len();
      let layout71 = _rt::alloc::Layout::from_size_align_unchecked(vec71.len() * 8, 4);
      let result71 = if layout71.size() != 0 {
        let ptr = _rt::alloc::alloc(layout71).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout71);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec71.into_iter().enumerate() {
        let base = result71.add(i * 8);
        {
          let vec70 = (e).into_boxed_slice();
          let ptr70 = vec70.as_ptr().cast::<u8>();
          let len70 = vec70.len();
          ::core::mem::forget(vec70);
          *base.add(4).cast::<usize>() = len70;
          *base.add(0).cast::<*mut u8>() = ptr70.cast_mut();
        }
      }
      *ptr58.add(60).cast::<usize>() = len71;
      *ptr58.add(56).cast::<*mut u8>() = result71;
      let super::super::super::super::delano::wallet::types::IssuerPublicCompressed{ parameters:parameters72, vk:vk72, } = issuer_public59;
      let super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{ pp_commit_g1:pp_commit_g173, pp_commit_g2:pp_commit_g273, } = parameters72;
      let vec75 = pp_commit_g173;
      let len75 = vec75.len();
      let layout75 = _rt::alloc::Layout::from_size_align_unchecked(vec75.len() * 8, 4);
      let result75 = if layout75.size() != 0 {
        let ptr = _rt::alloc::alloc(layout75).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout75);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec75.into_iter().enumerate() {
        let base = result75.add(i * 8);
        {
          let vec74 = (e).into_boxed_slice();
          let ptr74 = vec74.as_ptr().cast::<u8>();
          let len74 = vec74.len();
          ::core::mem::forget(vec74);
          *base.add(4).cast::<usize>() = len74;
          *base.add(0).cast::<*mut u8>() = ptr74.cast_mut();
        }
      }
      *ptr58.add(68).cast::<usize>() = len75;
      *ptr58.add(64).cast::<*mut u8>() = result75;
      let vec77 = pp_commit_g273;
      let len77 = vec77.len();
      let layout77 = _rt::alloc::Layout::from_size_align_unchecked(vec77.len() * 8, 4);
      let result77 = if layout77.size() != 0 {
        let ptr = _rt::alloc::alloc(layout77).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout77);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec77.into_iter().enumerate() {
        let base = result77.add(i * 8);
        {
          let vec76 = (e).into_boxed_slice();
          let ptr76 = vec76.as_ptr().cast::<u8>();
          let len76 = vec76.len();
          ::core::mem::forget(vec76);
          *base.add(4).cast::<usize>() = len76;
          *base.add(0).cast::<*mut u8>() = ptr76.cast_mut();
        }
      }
      *ptr58.add(76).cast::<usize>() = len77;
      *ptr58.add(72).cast::<*mut u8>() = result77;
      let vec81 = vk72;
      let len81 = vec81.len();
      let layout81 = _rt::alloc::Layout::from_size_align_unchecked(vec81.len() * 12, 4);
      let result81 = if layout81.size() != 0 {
        let ptr = _rt::alloc::alloc(layout81).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout81);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec81.into_iter().enumerate() {
        let base = result81.add(i * 12);
        {
          use super::super::super::super::delano::wallet::types::VkCompressed as V80;
          match e {
            V80::G1(e) => {
              *base.add(0).cast::<u8>() = (0i32) as u8;
              let vec78 = (e).into_boxed_slice();
              let ptr78 = vec78.as_ptr().cast::<u8>();
              let len78 = vec78.len();
              ::core::mem::forget(vec78);
              *base.add(8).cast::<usize>() = len78;
              *base.add(4).cast::<*mut u8>() = ptr78.cast_mut();
            },
            V80::G2(e) => {
              *base.add(0).cast::<u8>() = (1i32) as u8;
              let vec79 = (e).into_boxed_slice();
              let ptr79 = vec79.as_ptr().cast::<u8>();
              let len79 = vec79.len();
              ::core::mem::forget(vec79);
              *base.add(8).cast::<usize>() = len79;
              *base.add(4).cast::<*mut u8>() = ptr79.cast_mut();
            },
          }
        }
      }
      *ptr58.add(84).cast::<usize>() = len81;
      *ptr58.add(80).cast::<*mut u8>() = result81;
    } },
    Err(e) => { {
      *ptr58.add(0).cast::<u8>() = (1i32) as u8;
      let vec82 = (e.into_bytes()).into_boxed_slice();
      let ptr82 = vec82.as_ptr().cast::<u8>();
      let len82 = vec82.len();
      ::core::mem::forget(vec82);
      *ptr58.add(8).cast::<usize>() = len82;
      *ptr58.add(4).cast::<*mut u8>() = ptr82.cast_mut();
    } },
  };ptr58
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_accept<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
      let l4 = *arg0.add(12).cast::<*mut u8>();
      let l5 = *arg0.add(16).cast::<usize>();
      let base6 = l4;
      let len6 = l5;
      _rt::cabi_dealloc(base6, len6 * 1, 1);
      let l7 = *arg0.add(20).cast::<*mut u8>();
      let l8 = *arg0.add(24).cast::<usize>();
      let base9 = l7;
      let len9 = l8;
      _rt::cabi_dealloc(base9, len9 * 1, 1);
      let l10 = *arg0.add(28).cast::<*mut u8>();
      let l11 = *arg0.add(32).cast::<usize>();
      let base12 = l10;
      let len12 = l11;
      _rt::cabi_dealloc(base12, len12 * 1, 1);
      let l13 = i32::from(*arg0.add(36).cast::<u8>());
      match l13 {
        0 => (),
        _ => {
          let l14 = *arg0.add(40).cast::<*mut u8>();
          let l15 = *arg0.add(44).cast::<usize>();
          let base22 = l14;
          let len22 = l15;
          for i in 0..len22 {
            let base = base22.add(i * 8);
            {
              let l16 = *base.add(0).cast::<*mut u8>();
              let l17 = *base.add(4).cast::<usize>();
              let base21 = l16;
              let len21 = l17;
              for i in 0..len21 {
                let base = base21.add(i * 8);
                {
                  let l18 = *base.add(0).cast::<*mut u8>();
                  let l19 = *base.add(4).cast::<usize>();
                  let base20 = l18;
                  let len20 = l19;
                  _rt::cabi_dealloc(base20, len20 * 1, 1);
                }
              }
              _rt::cabi_dealloc(base21, len21 * 8, 4);
            }
          }
          _rt::cabi_dealloc(base22, len22 * 8, 4);
        },
      }
      let l23 = *arg0.add(48).cast::<*mut u8>();
      let l24 = *arg0.add(52).cast::<usize>();
      let base28 = l23;
      let len28 = l24;
      for i in 0..len28 {
        let base = base28.add(i * 8);
        {
          let l25 = *base.add(0).cast::<*mut u8>();
          let l26 = *base.add(4).cast::<usize>();
          let base27 = l25;
          let len27 = l26;
          _rt::cabi_dealloc(base27, len27 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base28, len28 * 8, 4);
      let l29 = *arg0.add(56).cast::<*mut u8>();
      let l30 = *arg0.add(60).cast::<usize>();
      let base34 = l29;
      let len34 = l30;
      for i in 0..len34 {
        let base = base34.add(i * 8);
        {
          let l31 = *base.add(0).cast::<*mut u8>();
          let l32 = *base.add(4).cast::<usize>();
          let base33 = l31;
          let len33 = l32;
          _rt::cabi_dealloc(base33, len33 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base34, len34 * 8, 4);
      let l35 = *arg0.add(64).cast::<*mut u8>();
      let l36 = *arg0.add(68).cast::<usize>();
      let base40 = l35;
      let len40 = l36;
      for i in 0..len40 {
        let base = base40.add(i * 8);
        {
          let l37 = *base.add(0).cast::<*mut u8>();
          let l38 = *base.add(4).cast::<usize>();
          let base39 = l37;
          let len39 = l38;
          _rt::cabi_dealloc(base39, len39 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base40, len40 * 8, 4);
      let l41 = *arg0.add(72).cast::<*mut u8>();
      let l42 = *arg0.add(76).cast::<usize>();
      let base46 = l41;
      let len46 = l42;
      for i in 0..len46 {
        let base = base46.add(i * 8);
        {
          let l43 = *base.add(0).cast::<*mut u8>();
          let l44 = *base.add(4).cast::<usize>();
          let base45 = l43;
          let len45 = l44;
          _rt::cabi_dealloc(base45, len45 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base46, len46 * 8, 4);
      let l47 = *arg0.add(80).cast::<*mut u8>();
      let l48 = *arg0.add(84).cast::<usize>();
      let base56 = l47;
      let len56 = l48;
      for i in 0..len56 {
        let base = base56.add(i * 12);
        {
          let l49 = i32::from(*base.add(0).cast::<u8>());
          match l49 {
            0 => {
              let l50 = *base.add(4).cast::<*mut u8>();
              let l51 = *base.add(8).cast::<usize>();
              let base52 = l50;
              let len52 = l51;
              _rt::cabi_dealloc(base52, len52 * 1, 1);
            },
            _ => {
              let l53 = *base.add(4).cast::<*mut u8>();
              let l54 = *base.add(8).cast::<usize>();
              let base55 = l53;
              let len55 = l54;
              _rt::cabi_dealloc(base55, len55 * 1, 1);
            },
          }
        }
      }
      _rt::cabi_dealloc(base56, len56 * 12, 4);
    },
    _ => {
      let l57 = *arg0.add(4).cast::<*mut u8>();
      let l58 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l57, l58, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_extend_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
let l1 = *arg0.add(4).cast::<usize>();
let len2 = l1;
let l3 = *arg0.add(8).cast::<*mut u8>();
let l4 = *arg0.add(12).cast::<usize>();
let len5 = l4;
let l6 = *arg0.add(16).cast::<*mut u8>();
let l7 = *arg0.add(20).cast::<usize>();
let len8 = l7;
let l9 = *arg0.add(24).cast::<*mut u8>();
let l10 = *arg0.add(28).cast::<usize>();
let len11 = l10;
let l12 = i32::from(*arg0.add(32).cast::<u8>());
let l22 = *arg0.add(44).cast::<*mut u8>();
let l23 = *arg0.add(48).cast::<usize>();
let base27 = l22;
let len27 = l23;
let mut result27 = _rt::Vec::with_capacity(len27);
for i in 0..len27 {
  let base = base27.add(i * 8);
  let e27 = {
    let l24 = *base.add(0).cast::<*mut u8>();
    let l25 = *base.add(4).cast::<usize>();
    let len26 = l25;

    _rt::Vec::from_raw_parts(l24.cast(), len26, len26)
  };
  result27.push(e27);
}
_rt::cabi_dealloc(base27, len27 * 8, 4);
let l28 = *arg0.add(52).cast::<*mut u8>();
let l29 = *arg0.add(56).cast::<usize>();
let base33 = l28;
let len33 = l29;
let mut result33 = _rt::Vec::with_capacity(len33);
for i in 0..len33 {
  let base = base33.add(i * 8);
  let e33 = {
    let l30 = *base.add(0).cast::<*mut u8>();
    let l31 = *base.add(4).cast::<usize>();
    let len32 = l31;

    _rt::Vec::from_raw_parts(l30.cast(), len32, len32)
  };
  result33.push(e33);
}
_rt::cabi_dealloc(base33, len33 * 8, 4);
let l34 = *arg0.add(60).cast::<*mut u8>();
let l35 = *arg0.add(64).cast::<usize>();
let base39 = l34;
let len39 = l35;
let mut result39 = _rt::Vec::with_capacity(len39);
for i in 0..len39 {
  let base = base39.add(i * 8);
  let e39 = {
    let l36 = *base.add(0).cast::<*mut u8>();
    let l37 = *base.add(4).cast::<usize>();
    let len38 = l37;

    _rt::Vec::from_raw_parts(l36.cast(), len38, len38)
  };
  result39.push(e39);
}
_rt::cabi_dealloc(base39, len39 * 8, 4);
let l40 = *arg0.add(68).cast::<*mut u8>();
let l41 = *arg0.add(72).cast::<usize>();
let base45 = l40;
let len45 = l41;
let mut result45 = _rt::Vec::with_capacity(len45);
for i in 0..len45 {
  let base = base45.add(i * 8);
  let e45 = {
    let l42 = *base.add(0).cast::<*mut u8>();
    let l43 = *base.add(4).cast::<usize>();
    let len44 = l43;

    _rt::Vec::from_raw_parts(l42.cast(), len44, len44)
  };
  result45.push(e45);
}
_rt::cabi_dealloc(base45, len45 * 8, 4);
let l46 = *arg0.add(76).cast::<*mut u8>();
let l47 = *arg0.add(80).cast::<usize>();
let base56 = l46;
let len56 = l47;
let mut result56 = _rt::Vec::with_capacity(len56);
for i in 0..len56 {
  let base = base56.add(i * 12);
  let e56 = {
    let l48 = i32::from(*base.add(0).cast::<u8>());
    use super::super::super::super::delano::wallet::types::VkCompressed as V55;
    let v55 = match l48 {
      0 => {
        let e55 = {
          let l49 = *base.add(4).cast::<*mut u8>();
          let l50 = *base.add(8).cast::<usize>();
          let len51 = l50;

          _rt::Vec::from_raw_parts(l49.cast(), len51, len51)
        };
        V55::G1(e55)
      }
      n => {
        debug_assert_eq!(n, 1, "invalid enum discriminant");
        let e55 = {
          let l52 = *base.add(4).cast::<*mut u8>();
          let l53 = *base.add(8).cast::<usize>();
          let len54 = l53;

          _rt::Vec::from_raw_parts(l52.cast(), len54, len54)
        };
        V55::G2(e55)
      }
    };

    v55
  };
  result56.push(e56);
}
_rt::cabi_dealloc(base56, len56 * 12, 4);
let l57 = *arg0.add(84).cast::<*mut u8>();
let l58 = *arg0.add(88).cast::<usize>();
let base62 = l57;
let len62 = l58;
let mut result62 = _rt::Vec::with_capacity(len62);
for i in 0..len62 {
  let base = base62.add(i * 8);
  let e62 = {
    let l59 = *base.add(0).cast::<*mut u8>();
    let l60 = *base.add(4).cast::<usize>();
    let len61 = l60;

    _rt::Vec::from_raw_parts(l59.cast(), len61, len61)
  };
  result62.push(e62);
}
_rt::cabi_dealloc(base62, len62 * 8, 4);
let result63 = T::extend(super::super::super::super::delano::wallet::types::CredentialCompressed{
  sigma: super::super::super::super::delano::wallet::types::SignatureCompressed{
    z: _rt::Vec::from_raw_parts(l0.cast(), len2, len2),
    y_g1: _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
    y_hat: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
    t: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
  },
  update_key: match l12 {
    0 => None,
    1 => {
      let e = {
        let l13 = *arg0.add(36).cast::<*mut u8>();
        let l14 = *arg0.add(40).cast::<usize>();
        let base21 = l13;
        let len21 = l14;
        let mut result21 = _rt::Vec::with_capacity(len21);
        for i in 0..len21 {
          let base = base21.add(i * 8);
          let e21 = {
            let l15 = *base.add(0).cast::<*mut u8>();
            let l16 = *base.add(4).cast::<usize>();
            let base20 = l15;
            let len20 = l16;
            let mut result20 = _rt::Vec::with_capacity(len20);
            for i in 0..len20 {
              let base = base20.add(i * 8);
              let e20 = {
                let l17 = *base.add(0).cast::<*mut u8>();
                let l18 = *base.add(4).cast::<usize>();
                let len19 = l18;

                _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
              };
              result20.push(e20);
            }
            _rt::cabi_dealloc(base20, len20 * 8, 4);

            result20
          };
          result21.push(e21);
        }
        _rt::cabi_dealloc(base21, len21 * 8, 4);

        result21
      };
      Some(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  },
  commitment_vector: result27,
  opening_vector: result33,
  issuer_public: super::super::super::super::delano::wallet::types::IssuerPublicCompressed{
    parameters: super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{
      pp_commit_g1: result39,
      pp_commit_g2: result45,
    },
    vk: result56,
  },
}, result62);
_rt::cabi_dealloc(arg0, 92, 4);
let ptr64 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result63 {
  Ok(e) => { {
    *ptr64.add(0).cast::<u8>() = (0i32) as u8;
    let super::super::super::super::delano::wallet::types::CredentialCompressed{ sigma:sigma65, update_key:update_key65, commitment_vector:commitment_vector65, opening_vector:opening_vector65, issuer_public:issuer_public65, } = e;
    let super::super::super::super::delano::wallet::types::SignatureCompressed{ z:z66, y_g1:y_g166, y_hat:y_hat66, t:t66, } = sigma65;
    let vec67 = (z66).into_boxed_slice();
    let ptr67 = vec67.as_ptr().cast::<u8>();
    let len67 = vec67.len();
    ::core::mem::forget(vec67);
    *ptr64.add(8).cast::<usize>() = len67;
    *ptr64.add(4).cast::<*mut u8>() = ptr67.cast_mut();
    let vec68 = (y_g166).into_boxed_slice();
    let ptr68 = vec68.as_ptr().cast::<u8>();
    let len68 = vec68.len();
    ::core::mem::forget(vec68);
    *ptr64.add(16).cast::<usize>() = len68;
    *ptr64.add(12).cast::<*mut u8>() = ptr68.cast_mut();
    let vec69 = (y_hat66).into_boxed_slice();
    let ptr69 = vec69.as_ptr().cast::<u8>();
    let len69 = vec69.len();
    ::core::mem::forget(vec69);
    *ptr64.add(24).cast::<usize>() = len69;
    *ptr64.add(20).cast::<*mut u8>() = ptr69.cast_mut();
    let vec70 = (t66).into_boxed_slice();
    let ptr70 = vec70.as_ptr().cast::<u8>();
    let len70 = vec70.len();
    ::core::mem::forget(vec70);
    *ptr64.add(32).cast::<usize>() = len70;
    *ptr64.add(28).cast::<*mut u8>() = ptr70.cast_mut();
    match update_key65 {
      Some(e) => {
        *ptr64.add(36).cast::<u8>() = (1i32) as u8;
        let vec73 = e;
        let len73 = vec73.len();
        let layout73 = _rt::alloc::Layout::from_size_align_unchecked(vec73.len() * 8, 4);
        let result73 = if layout73.size() != 0 {
          let ptr = _rt::alloc::alloc(layout73).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout73);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec73.into_iter().enumerate() {
          let base = result73.add(i * 8);
          {
            let vec72 = e;
            let len72 = vec72.len();
            let layout72 = _rt::alloc::Layout::from_size_align_unchecked(vec72.len() * 8, 4);
            let result72 = if layout72.size() != 0 {
              let ptr = _rt::alloc::alloc(layout72).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout72);
              }
              ptr
            }else {
              ::core::ptr::null_mut()
            };
            for (i, e) in vec72.into_iter().enumerate() {
              let base = result72.add(i * 8);
              {
                let vec71 = (e).into_boxed_slice();
                let ptr71 = vec71.as_ptr().cast::<u8>();
                let len71 = vec71.len();
                ::core::mem::forget(vec71);
                *base.add(4).cast::<usize>() = len71;
                *base.add(0).cast::<*mut u8>() = ptr71.cast_mut();
              }
            }
            *base.add(4).cast::<usize>() = len72;
            *base.add(0).cast::<*mut u8>() = result72;
          }
        }
        *ptr64.add(44).cast::<usize>() = len73;
        *ptr64.add(40).cast::<*mut u8>() = result73;
      },
      None => {
        {
          *ptr64.add(36).cast::<u8>() = (0i32) as u8;
        }
      },
    };let vec75 = commitment_vector65;
    let len75 = vec75.len();
    let layout75 = _rt::alloc::Layout::from_size_align_unchecked(vec75.len() * 8, 4);
    let result75 = if layout75.size() != 0 {
      let ptr = _rt::alloc::alloc(layout75).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout75);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec75.into_iter().enumerate() {
      let base = result75.add(i * 8);
      {
        let vec74 = (e).into_boxed_slice();
        let ptr74 = vec74.as_ptr().cast::<u8>();
        let len74 = vec74.len();
        ::core::mem::forget(vec74);
        *base.add(4).cast::<usize>() = len74;
        *base.add(0).cast::<*mut u8>() = ptr74.cast_mut();
      }
    }
    *ptr64.add(52).cast::<usize>() = len75;
    *ptr64.add(48).cast::<*mut u8>() = result75;
    let vec77 = opening_vector65;
    let len77 = vec77.len();
    let layout77 = _rt::alloc::Layout::from_size_align_unchecked(vec77.len() * 8, 4);
    let result77 = if layout77.size() != 0 {
      let ptr = _rt::alloc::alloc(layout77).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout77);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec77.into_iter().enumerate() {
      let base = result77.add(i * 8);
      {
        let vec76 = (e).into_boxed_slice();
        let ptr76 = vec76.as_ptr().cast::<u8>();
        let len76 = vec76.len();
        ::core::mem::forget(vec76);
        *base.add(4).cast::<usize>() = len76;
        *base.add(0).cast::<*mut u8>() = ptr76.cast_mut();
      }
    }
    *ptr64.add(60).cast::<usize>() = len77;
    *ptr64.add(56).cast::<*mut u8>() = result77;
    let super::super::super::super::delano::wallet::types::IssuerPublicCompressed{ parameters:parameters78, vk:vk78, } = issuer_public65;
    let super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{ pp_commit_g1:pp_commit_g179, pp_commit_g2:pp_commit_g279, } = parameters78;
    let vec81 = pp_commit_g179;
    let len81 = vec81.len();
    let layout81 = _rt::alloc::Layout::from_size_align_unchecked(vec81.len() * 8, 4);
    let result81 = if layout81.size() != 0 {
      let ptr = _rt::alloc::alloc(layout81).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout81);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec81.into_iter().enumerate() {
      let base = result81.add(i * 8);
      {
        let vec80 = (e).into_boxed_slice();
        let ptr80 = vec80.as_ptr().cast::<u8>();
        let len80 = vec80.len();
        ::core::mem::forget(vec80);
        *base.add(4).cast::<usize>() = len80;
        *base.add(0).cast::<*mut u8>() = ptr80.cast_mut();
      }
    }
    *ptr64.add(68).cast::<usize>() = len81;
    *ptr64.add(64).cast::<*mut u8>() = result81;
    let vec83 = pp_commit_g279;
    let len83 = vec83.len();
    let layout83 = _rt::alloc::Layout::from_size_align_unchecked(vec83.len() * 8, 4);
    let result83 = if layout83.size() != 0 {
      let ptr = _rt::alloc::alloc(layout83).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout83);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec83.into_iter().enumerate() {
      let base = result83.add(i * 8);
      {
        let vec82 = (e).into_boxed_slice();
        let ptr82 = vec82.as_ptr().cast::<u8>();
        let len82 = vec82.len();
        ::core::mem::forget(vec82);
        *base.add(4).cast::<usize>() = len82;
        *base.add(0).cast::<*mut u8>() = ptr82.cast_mut();
      }
    }
    *ptr64.add(76).cast::<usize>() = len83;
    *ptr64.add(72).cast::<*mut u8>() = result83;
    let vec87 = vk78;
    let len87 = vec87.len();
    let layout87 = _rt::alloc::Layout::from_size_align_unchecked(vec87.len() * 12, 4);
    let result87 = if layout87.size() != 0 {
      let ptr = _rt::alloc::alloc(layout87).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout87);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec87.into_iter().enumerate() {
      let base = result87.add(i * 12);
      {
        use super::super::super::super::delano::wallet::types::VkCompressed as V86;
        match e {
          V86::G1(e) => {
            *base.add(0).cast::<u8>() = (0i32) as u8;
            let vec84 = (e).into_boxed_slice();
            let ptr84 = vec84.as_ptr().cast::<u8>();
            let len84 = vec84.len();
            ::core::mem::forget(vec84);
            *base.add(8).cast::<usize>() = len84;
            *base.add(4).cast::<*mut u8>() = ptr84.cast_mut();
          },
          V86::G2(e) => {
            *base.add(0).cast::<u8>() = (1i32) as u8;
            let vec85 = (e).into_boxed_slice();
            let ptr85 = vec85.as_ptr().cast::<u8>();
            let len85 = vec85.len();
            ::core::mem::forget(vec85);
            *base.add(8).cast::<usize>() = len85;
            *base.add(4).cast::<*mut u8>() = ptr85.cast_mut();
          },
        }
      }
    }
    *ptr64.add(84).cast::<usize>() = len87;
    *ptr64.add(80).cast::<*mut u8>() = result87;
  } },
  Err(e) => { {
    *ptr64.add(0).cast::<u8>() = (1i32) as u8;
    let vec88 = (e.into_bytes()).into_boxed_slice();
    let ptr88 = vec88.as_ptr().cast::<u8>();
    let len88 = vec88.len();
    ::core::mem::forget(vec88);
    *ptr64.add(8).cast::<usize>() = len88;
    *ptr64.add(4).cast::<*mut u8>() = ptr88.cast_mut();
  } },
};ptr64
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_extend<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
      let l4 = *arg0.add(12).cast::<*mut u8>();
      let l5 = *arg0.add(16).cast::<usize>();
      let base6 = l4;
      let len6 = l5;
      _rt::cabi_dealloc(base6, len6 * 1, 1);
      let l7 = *arg0.add(20).cast::<*mut u8>();
      let l8 = *arg0.add(24).cast::<usize>();
      let base9 = l7;
      let len9 = l8;
      _rt::cabi_dealloc(base9, len9 * 1, 1);
      let l10 = *arg0.add(28).cast::<*mut u8>();
      let l11 = *arg0.add(32).cast::<usize>();
      let base12 = l10;
      let len12 = l11;
      _rt::cabi_dealloc(base12, len12 * 1, 1);
      let l13 = i32::from(*arg0.add(36).cast::<u8>());
      match l13 {
        0 => (),
        _ => {
          let l14 = *arg0.add(40).cast::<*mut u8>();
          let l15 = *arg0.add(44).cast::<usize>();
          let base22 = l14;
          let len22 = l15;
          for i in 0..len22 {
            let base = base22.add(i * 8);
            {
              let l16 = *base.add(0).cast::<*mut u8>();
              let l17 = *base.add(4).cast::<usize>();
              let base21 = l16;
              let len21 = l17;
              for i in 0..len21 {
                let base = base21.add(i * 8);
                {
                  let l18 = *base.add(0).cast::<*mut u8>();
                  let l19 = *base.add(4).cast::<usize>();
                  let base20 = l18;
                  let len20 = l19;
                  _rt::cabi_dealloc(base20, len20 * 1, 1);
                }
              }
              _rt::cabi_dealloc(base21, len21 * 8, 4);
            }
          }
          _rt::cabi_dealloc(base22, len22 * 8, 4);
        },
      }
      let l23 = *arg0.add(48).cast::<*mut u8>();
      let l24 = *arg0.add(52).cast::<usize>();
      let base28 = l23;
      let len28 = l24;
      for i in 0..len28 {
        let base = base28.add(i * 8);
        {
          let l25 = *base.add(0).cast::<*mut u8>();
          let l26 = *base.add(4).cast::<usize>();
          let base27 = l25;
          let len27 = l26;
          _rt::cabi_dealloc(base27, len27 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base28, len28 * 8, 4);
      let l29 = *arg0.add(56).cast::<*mut u8>();
      let l30 = *arg0.add(60).cast::<usize>();
      let base34 = l29;
      let len34 = l30;
      for i in 0..len34 {
        let base = base34.add(i * 8);
        {
          let l31 = *base.add(0).cast::<*mut u8>();
          let l32 = *base.add(4).cast::<usize>();
          let base33 = l31;
          let len33 = l32;
          _rt::cabi_dealloc(base33, len33 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base34, len34 * 8, 4);
      let l35 = *arg0.add(64).cast::<*mut u8>();
      let l36 = *arg0.add(68).cast::<usize>();
      let base40 = l35;
      let len40 = l36;
      for i in 0..len40 {
        let base = base40.add(i * 8);
        {
          let l37 = *base.add(0).cast::<*mut u8>();
          let l38 = *base.add(4).cast::<usize>();
          let base39 = l37;
          let len39 = l38;
          _rt::cabi_dealloc(base39, len39 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base40, len40 * 8, 4);
      let l41 = *arg0.add(72).cast::<*mut u8>();
      let l42 = *arg0.add(76).cast::<usize>();
      let base46 = l41;
      let len46 = l42;
      for i in 0..len46 {
        let base = base46.add(i * 8);
        {
          let l43 = *base.add(0).cast::<*mut u8>();
          let l44 = *base.add(4).cast::<usize>();
          let base45 = l43;
          let len45 = l44;
          _rt::cabi_dealloc(base45, len45 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base46, len46 * 8, 4);
      let l47 = *arg0.add(80).cast::<*mut u8>();
      let l48 = *arg0.add(84).cast::<usize>();
      let base56 = l47;
      let len56 = l48;
      for i in 0..len56 {
        let base = base56.add(i * 12);
        {
          let l49 = i32::from(*base.add(0).cast::<u8>());
          match l49 {
            0 => {
              let l50 = *base.add(4).cast::<*mut u8>();
              let l51 = *base.add(8).cast::<usize>();
              let base52 = l50;
              let len52 = l51;
              _rt::cabi_dealloc(base52, len52 * 1, 1);
            },
            _ => {
              let l53 = *base.add(4).cast::<*mut u8>();
              let l54 = *base.add(8).cast::<usize>();
              let base55 = l53;
              let len55 = l54;
              _rt::cabi_dealloc(base55, len55 * 1, 1);
            },
          }
        }
      }
      _rt::cabi_dealloc(base56, len56 * 12, 4);
    },
    _ => {
      let l57 = *arg0.add(4).cast::<*mut u8>();
      let l58 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l57, l58, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_prove_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
let l1 = *arg0.add(4).cast::<usize>();
let len2 = l1;
let l3 = *arg0.add(8).cast::<*mut u8>();
let l4 = *arg0.add(12).cast::<usize>();
let len5 = l4;
let l6 = *arg0.add(16).cast::<*mut u8>();
let l7 = *arg0.add(20).cast::<usize>();
let len8 = l7;
let l9 = *arg0.add(24).cast::<*mut u8>();
let l10 = *arg0.add(28).cast::<usize>();
let len11 = l10;
let l12 = i32::from(*arg0.add(32).cast::<u8>());
let l22 = *arg0.add(44).cast::<*mut u8>();
let l23 = *arg0.add(48).cast::<usize>();
let base27 = l22;
let len27 = l23;
let mut result27 = _rt::Vec::with_capacity(len27);
for i in 0..len27 {
  let base = base27.add(i * 8);
  let e27 = {
    let l24 = *base.add(0).cast::<*mut u8>();
    let l25 = *base.add(4).cast::<usize>();
    let len26 = l25;

    _rt::Vec::from_raw_parts(l24.cast(), len26, len26)
  };
  result27.push(e27);
}
_rt::cabi_dealloc(base27, len27 * 8, 4);
let l28 = *arg0.add(52).cast::<*mut u8>();
let l29 = *arg0.add(56).cast::<usize>();
let base33 = l28;
let len33 = l29;
let mut result33 = _rt::Vec::with_capacity(len33);
for i in 0..len33 {
  let base = base33.add(i * 8);
  let e33 = {
    let l30 = *base.add(0).cast::<*mut u8>();
    let l31 = *base.add(4).cast::<usize>();
    let len32 = l31;

    _rt::Vec::from_raw_parts(l30.cast(), len32, len32)
  };
  result33.push(e33);
}
_rt::cabi_dealloc(base33, len33 * 8, 4);
let l34 = *arg0.add(60).cast::<*mut u8>();
let l35 = *arg0.add(64).cast::<usize>();
let base39 = l34;
let len39 = l35;
let mut result39 = _rt::Vec::with_capacity(len39);
for i in 0..len39 {
  let base = base39.add(i * 8);
  let e39 = {
    let l36 = *base.add(0).cast::<*mut u8>();
    let l37 = *base.add(4).cast::<usize>();
    let len38 = l37;

    _rt::Vec::from_raw_parts(l36.cast(), len38, len38)
  };
  result39.push(e39);
}
_rt::cabi_dealloc(base39, len39 * 8, 4);
let l40 = *arg0.add(68).cast::<*mut u8>();
let l41 = *arg0.add(72).cast::<usize>();
let base45 = l40;
let len45 = l41;
let mut result45 = _rt::Vec::with_capacity(len45);
for i in 0..len45 {
  let base = base45.add(i * 8);
  let e45 = {
    let l42 = *base.add(0).cast::<*mut u8>();
    let l43 = *base.add(4).cast::<usize>();
    let len44 = l43;

    _rt::Vec::from_raw_parts(l42.cast(), len44, len44)
  };
  result45.push(e45);
}
_rt::cabi_dealloc(base45, len45 * 8, 4);
let l46 = *arg0.add(76).cast::<*mut u8>();
let l47 = *arg0.add(80).cast::<usize>();
let base56 = l46;
let len56 = l47;
let mut result56 = _rt::Vec::with_capacity(len56);
for i in 0..len56 {
  let base = base56.add(i * 12);
  let e56 = {
    let l48 = i32::from(*base.add(0).cast::<u8>());
    use super::super::super::super::delano::wallet::types::VkCompressed as V55;
    let v55 = match l48 {
      0 => {
        let e55 = {
          let l49 = *base.add(4).cast::<*mut u8>();
          let l50 = *base.add(8).cast::<usize>();
          let len51 = l50;

          _rt::Vec::from_raw_parts(l49.cast(), len51, len51)
        };
        V55::G1(e55)
      }
      n => {
        debug_assert_eq!(n, 1, "invalid enum discriminant");
        let e55 = {
          let l52 = *base.add(4).cast::<*mut u8>();
          let l53 = *base.add(8).cast::<usize>();
          let len54 = l53;

          _rt::Vec::from_raw_parts(l52.cast(), len54, len54)
        };
        V55::G2(e55)
      }
    };

    v55
  };
  result56.push(e56);
}
_rt::cabi_dealloc(base56, len56 * 12, 4);
let l57 = *arg0.add(84).cast::<*mut u8>();
let l58 = *arg0.add(88).cast::<usize>();
let base65 = l57;
let len65 = l58;
let mut result65 = _rt::Vec::with_capacity(len65);
for i in 0..len65 {
  let base = base65.add(i * 8);
  let e65 = {
    let l59 = *base.add(0).cast::<*mut u8>();
    let l60 = *base.add(4).cast::<usize>();
    let base64 = l59;
    let len64 = l60;
    let mut result64 = _rt::Vec::with_capacity(len64);
    for i in 0..len64 {
      let base = base64.add(i * 8);
      let e64 = {
        let l61 = *base.add(0).cast::<*mut u8>();
        let l62 = *base.add(4).cast::<usize>();
        let len63 = l62;

        _rt::Vec::from_raw_parts(l61.cast(), len63, len63)
      };
      result64.push(e64);
    }
    _rt::cabi_dealloc(base64, len64 * 8, 4);

    result64
  };
  result65.push(e65);
}
_rt::cabi_dealloc(base65, len65 * 8, 4);
let l66 = *arg0.add(92).cast::<*mut u8>();
let l67 = *arg0.add(96).cast::<usize>();
let base71 = l66;
let len71 = l67;
let mut result71 = _rt::Vec::with_capacity(len71);
for i in 0..len71 {
  let base = base71.add(i * 8);
  let e71 = {
    let l68 = *base.add(0).cast::<*mut u8>();
    let l69 = *base.add(4).cast::<usize>();
    let len70 = l69;

    _rt::Vec::from_raw_parts(l68.cast(), len70, len70)
  };
  result71.push(e71);
}
_rt::cabi_dealloc(base71, len71 * 8, 4);
let l72 = *arg0.add(100).cast::<*mut u8>();
let l73 = *arg0.add(104).cast::<usize>();
let len74 = l73;
let result75 = T::prove(super::super::super::super::delano::wallet::types::Provables{
  credential: super::super::super::super::delano::wallet::types::CredentialCompressed{
    sigma: super::super::super::super::delano::wallet::types::SignatureCompressed{
      z: _rt::Vec::from_raw_parts(l0.cast(), len2, len2),
      y_g1: _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
      y_hat: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
      t: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
    },
    update_key: match l12 {
      0 => None,
      1 => {
        let e = {
          let l13 = *arg0.add(36).cast::<*mut u8>();
          let l14 = *arg0.add(40).cast::<usize>();
          let base21 = l13;
          let len21 = l14;
          let mut result21 = _rt::Vec::with_capacity(len21);
          for i in 0..len21 {
            let base = base21.add(i * 8);
            let e21 = {
              let l15 = *base.add(0).cast::<*mut u8>();
              let l16 = *base.add(4).cast::<usize>();
              let base20 = l15;
              let len20 = l16;
              let mut result20 = _rt::Vec::with_capacity(len20);
              for i in 0..len20 {
                let base = base20.add(i * 8);
                let e20 = {
                  let l17 = *base.add(0).cast::<*mut u8>();
                  let l18 = *base.add(4).cast::<usize>();
                  let len19 = l18;

                  _rt::Vec::from_raw_parts(l17.cast(), len19, len19)
                };
                result20.push(e20);
              }
              _rt::cabi_dealloc(base20, len20 * 8, 4);

              result20
            };
            result21.push(e21);
          }
          _rt::cabi_dealloc(base21, len21 * 8, 4);

          result21
        };
        Some(e)
      }
      _ => _rt::invalid_enum_discriminant(),
    },
    commitment_vector: result27,
    opening_vector: result33,
    issuer_public: super::super::super::super::delano::wallet::types::IssuerPublicCompressed{
      parameters: super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{
        pp_commit_g1: result39,
        pp_commit_g2: result45,
      },
      vk: result56,
    },
  },
  entries: result65,
  selected: result71,
  nonce: _rt::Vec::from_raw_parts(l72.cast(), len74, len74),
});
_rt::cabi_dealloc(arg0, 108, 4);
let ptr76 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result75 {
  Ok(e) => { {
    *ptr76.add(0).cast::<u8>() = (0i32) as u8;
    let super::super::super::super::delano::wallet::types::Proven{ proof:proof77, selected:selected77, } = e;
    let super::super::super::super::delano::wallet::types::CredProofCompressed{ sigma:sigma78, commitment_vector:commitment_vector78, witness_pi:witness_pi78, nym_proof:nym_proof78, } = proof77;
    let super::super::super::super::delano::wallet::types::SignatureCompressed{ z:z79, y_g1:y_g179, y_hat:y_hat79, t:t79, } = sigma78;
    let vec80 = (z79).into_boxed_slice();
    let ptr80 = vec80.as_ptr().cast::<u8>();
    let len80 = vec80.len();
    ::core::mem::forget(vec80);
    *ptr76.add(8).cast::<usize>() = len80;
    *ptr76.add(4).cast::<*mut u8>() = ptr80.cast_mut();
    let vec81 = (y_g179).into_boxed_slice();
    let ptr81 = vec81.as_ptr().cast::<u8>();
    let len81 = vec81.len();
    ::core::mem::forget(vec81);
    *ptr76.add(16).cast::<usize>() = len81;
    *ptr76.add(12).cast::<*mut u8>() = ptr81.cast_mut();
    let vec82 = (y_hat79).into_boxed_slice();
    let ptr82 = vec82.as_ptr().cast::<u8>();
    let len82 = vec82.len();
    ::core::mem::forget(vec82);
    *ptr76.add(24).cast::<usize>() = len82;
    *ptr76.add(20).cast::<*mut u8>() = ptr82.cast_mut();
    let vec83 = (t79).into_boxed_slice();
    let ptr83 = vec83.as_ptr().cast::<u8>();
    let len83 = vec83.len();
    ::core::mem::forget(vec83);
    *ptr76.add(32).cast::<usize>() = len83;
    *ptr76.add(28).cast::<*mut u8>() = ptr83.cast_mut();
    let vec85 = commitment_vector78;
    let len85 = vec85.len();
    let layout85 = _rt::alloc::Layout::from_size_align_unchecked(vec85.len() * 8, 4);
    let result85 = if layout85.size() != 0 {
      let ptr = _rt::alloc::alloc(layout85).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout85);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec85.into_iter().enumerate() {
      let base = result85.add(i * 8);
      {
        let vec84 = (e).into_boxed_slice();
        let ptr84 = vec84.as_ptr().cast::<u8>();
        let len84 = vec84.len();
        ::core::mem::forget(vec84);
        *base.add(4).cast::<usize>() = len84;
        *base.add(0).cast::<*mut u8>() = ptr84.cast_mut();
      }
    }
    *ptr76.add(40).cast::<usize>() = len85;
    *ptr76.add(36).cast::<*mut u8>() = result85;
    let vec86 = (witness_pi78).into_boxed_slice();
    let ptr86 = vec86.as_ptr().cast::<u8>();
    let len86 = vec86.len();
    ::core::mem::forget(vec86);
    *ptr76.add(48).cast::<usize>() = len86;
    *ptr76.add(44).cast::<*mut u8>() = ptr86.cast_mut();
    let super::super::super::super::delano::wallet::types::NymProofCompressed{ challenge:challenge87, pedersen_open:pedersen_open87, pedersen_commit:pedersen_commit87, public_key:public_key87, response:response87, damgard:damgard87, } = nym_proof78;
    let vec88 = (challenge87).into_boxed_slice();
    let ptr88 = vec88.as_ptr().cast::<u8>();
    let len88 = vec88.len();
    ::core::mem::forget(vec88);
    *ptr76.add(56).cast::<usize>() = len88;
    *ptr76.add(52).cast::<*mut u8>() = ptr88.cast_mut();
    let super::super::super::super::delano::wallet::types::PedersenOpenCompressed{ open_randomness:open_randomness89, announce_randomness:announce_randomness89, announce_element:announce_element89, } = pedersen_open87;
    let vec90 = (open_randomness89).into_boxed_slice();
    let ptr90 = vec90.as_ptr().cast::<u8>();
    let len90 = vec90.len();
    ::core::mem::forget(vec90);
    *ptr76.add(64).cast::<usize>() = len90;
    *ptr76.add(60).cast::<*mut u8>() = ptr90.cast_mut();
    let vec91 = (announce_randomness89).into_boxed_slice();
    let ptr91 = vec91.as_ptr().cast::<u8>();
    let len91 = vec91.len();
    ::core::mem::forget(vec91);
    *ptr76.add(72).cast::<usize>() = len91;
    *ptr76.add(68).cast::<*mut u8>() = ptr91.cast_mut();
    match announce_element89 {
      Some(e) => {
        *ptr76.add(76).cast::<u8>() = (1i32) as u8;
        let vec92 = (e).into_boxed_slice();
        let ptr92 = vec92.as_ptr().cast::<u8>();
        let len92 = vec92.len();
        ::core::mem::forget(vec92);
        *ptr76.add(84).cast::<usize>() = len92;
        *ptr76.add(80).cast::<*mut u8>() = ptr92.cast_mut();
      },
      None => {
        {
          *ptr76.add(76).cast::<u8>() = (0i32) as u8;
        }
      },
    };let vec93 = (pedersen_commit87).into_boxed_slice();
    let ptr93 = vec93.as_ptr().cast::<u8>();
    let len93 = vec93.len();
    ::core::mem::forget(vec93);
    *ptr76.add(92).cast::<usize>() = len93;
    *ptr76.add(88).cast::<*mut u8>() = ptr93.cast_mut();
    let vec94 = (public_key87).into_boxed_slice();
    let ptr94 = vec94.as_ptr().cast::<u8>();
    let len94 = vec94.len();
    ::core::mem::forget(vec94);
    *ptr76.add(100).cast::<usize>() = len94;
    *ptr76.add(96).cast::<*mut u8>() = ptr94.cast_mut();
    let vec95 = (response87).into_boxed_slice();
    let ptr95 = vec95.as_ptr().cast::<u8>();
    let len95 = vec95.len();
    ::core::mem::forget(vec95);
    *ptr76.add(108).cast::<usize>() = len95;
    *ptr76.add(104).cast::<*mut u8>() = ptr95.cast_mut();
    let super::super::super::super::delano::wallet::types::DamgardTransformCompressed{ pedersen:pedersen96, } = damgard87;
    let super::super::super::super::delano::wallet::types::PedersenCompressed{ h:h97, } = pedersen96;
    let vec98 = (h97).into_boxed_slice();
    let ptr98 = vec98.as_ptr().cast::<u8>();
    let len98 = vec98.len();
    ::core::mem::forget(vec98);
    *ptr76.add(116).cast::<usize>() = len98;
    *ptr76.add(112).cast::<*mut u8>() = ptr98.cast_mut();
    let vec101 = selected77;
    let len101 = vec101.len();
    let layout101 = _rt::alloc::Layout::from_size_align_unchecked(vec101.len() * 8, 4);
    let result101 = if layout101.size() != 0 {
      let ptr = _rt::alloc::alloc(layout101).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout101);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec101.into_iter().enumerate() {
      let base = result101.add(i * 8);
      {
        let vec100 = e;
        let len100 = vec100.len();
        let layout100 = _rt::alloc::Layout::from_size_align_unchecked(vec100.len() * 8, 4);
        let result100 = if layout100.size() != 0 {
          let ptr = _rt::alloc::alloc(layout100).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout100);
          }
          ptr
        }else {
          ::core::ptr::null_mut()
        };
        for (i, e) in vec100.into_iter().enumerate() {
          let base = result100.add(i * 8);
          {
            let vec99 = (e).into_boxed_slice();
            let ptr99 = vec99.as_ptr().cast::<u8>();
            let len99 = vec99.len();
            ::core::mem::forget(vec99);
            *base.add(4).cast::<usize>() = len99;
            *base.add(0).cast::<*mut u8>() = ptr99.cast_mut();
          }
        }
        *base.add(4).cast::<usize>() = len100;
        *base.add(0).cast::<*mut u8>() = result100;
      }
    }
    *ptr76.add(124).cast::<usize>() = len101;
    *ptr76.add(120).cast::<*mut u8>() = result101;
  } },
  Err(e) => { {
    *ptr76.add(0).cast::<u8>() = (1i32) as u8;
    let vec102 = (e.into_bytes()).into_boxed_slice();
    let ptr102 = vec102.as_ptr().cast::<u8>();
    let len102 = vec102.len();
    ::core::mem::forget(vec102);
    *ptr76.add(8).cast::<usize>() = len102;
    *ptr76.add(4).cast::<*mut u8>() = ptr102.cast_mut();
  } },
};ptr76
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_prove<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base3 = l1;
      let len3 = l2;
      _rt::cabi_dealloc(base3, len3 * 1, 1);
      let l4 = *arg0.add(12).cast::<*mut u8>();
      let l5 = *arg0.add(16).cast::<usize>();
      let base6 = l4;
      let len6 = l5;
      _rt::cabi_dealloc(base6, len6 * 1, 1);
      let l7 = *arg0.add(20).cast::<*mut u8>();
      let l8 = *arg0.add(24).cast::<usize>();
      let base9 = l7;
      let len9 = l8;
      _rt::cabi_dealloc(base9, len9 * 1, 1);
      let l10 = *arg0.add(28).cast::<*mut u8>();
      let l11 = *arg0.add(32).cast::<usize>();
      let base12 = l10;
      let len12 = l11;
      _rt::cabi_dealloc(base12, len12 * 1, 1);
      let l13 = *arg0.add(36).cast::<*mut u8>();
      let l14 = *arg0.add(40).cast::<usize>();
      let base18 = l13;
      let len18 = l14;
      for i in 0..len18 {
        let base = base18.add(i * 8);
        {
          let l15 = *base.add(0).cast::<*mut u8>();
          let l16 = *base.add(4).cast::<usize>();
          let base17 = l15;
          let len17 = l16;
          _rt::cabi_dealloc(base17, len17 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base18, len18 * 8, 4);
      let l19 = *arg0.add(44).cast::<*mut u8>();
      let l20 = *arg0.add(48).cast::<usize>();
      let base21 = l19;
      let len21 = l20;
      _rt::cabi_dealloc(base21, len21 * 1, 1);
      let l22 = *arg0.add(52).cast::<*mut u8>();
      let l23 = *arg0.add(56).cast::<usize>();
      let base24 = l22;
      let len24 = l23;
      _rt::cabi_dealloc(base24, len24 * 1, 1);
      let l25 = *arg0.add(60).cast::<*mut u8>();
      let l26 = *arg0.add(64).cast::<usize>();
      let base27 = l25;
      let len27 = l26;
      _rt::cabi_dealloc(base27, len27 * 1, 1);
      let l28 = *arg0.add(68).cast::<*mut u8>();
      let l29 = *arg0.add(72).cast::<usize>();
      let base30 = l28;
      let len30 = l29;
      _rt::cabi_dealloc(base30, len30 * 1, 1);
      let l31 = i32::from(*arg0.add(76).cast::<u8>());
      match l31 {
        0 => (),
        _ => {
          let l32 = *arg0.add(80).cast::<*mut u8>();
          let l33 = *arg0.add(84).cast::<usize>();
          let base34 = l32;
          let len34 = l33;
          _rt::cabi_dealloc(base34, len34 * 1, 1);
        },
      }
      let l35 = *arg0.add(88).cast::<*mut u8>();
      let l36 = *arg0.add(92).cast::<usize>();
      let base37 = l35;
      let len37 = l36;
      _rt::cabi_dealloc(base37, len37 * 1, 1);
      let l38 = *arg0.add(96).cast::<*mut u8>();
      let l39 = *arg0.add(100).cast::<usize>();
      let base40 = l38;
      let len40 = l39;
      _rt::cabi_dealloc(base40, len40 * 1, 1);
      let l41 = *arg0.add(104).cast::<*mut u8>();
      let l42 = *arg0.add(108).cast::<usize>();
      let base43 = l41;
      let len43 = l42;
      _rt::cabi_dealloc(base43, len43 * 1, 1);
      let l44 = *arg0.add(112).cast::<*mut u8>();
      let l45 = *arg0.add(116).cast::<usize>();
      let base46 = l44;
      let len46 = l45;
      _rt::cabi_dealloc(base46, len46 * 1, 1);
      let l47 = *arg0.add(120).cast::<*mut u8>();
      let l48 = *arg0.add(124).cast::<usize>();
      let base55 = l47;
      let len55 = l48;
      for i in 0..len55 {
        let base = base55.add(i * 8);
        {
          let l49 = *base.add(0).cast::<*mut u8>();
          let l50 = *base.add(4).cast::<usize>();
          let base54 = l49;
          let len54 = l50;
          for i in 0..len54 {
            let base = base54.add(i * 8);
            {
              let l51 = *base.add(0).cast::<*mut u8>();
              let l52 = *base.add(4).cast::<usize>();
              let base53 = l51;
              let len53 = l52;
              _rt::cabi_dealloc(base53, len53 * 1, 1);
            }
          }
          _rt::cabi_dealloc(base54, len54 * 8, 4);
        }
      }
      _rt::cabi_dealloc(base55, len55 * 8, 4);
    },
    _ => {
      let l56 = *arg0.add(4).cast::<*mut u8>();
      let l57 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l56, l57, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_verify_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let l0 = *arg0.add(0).cast::<*mut u8>();
let l1 = *arg0.add(4).cast::<usize>();
let len2 = l1;
let l3 = *arg0.add(8).cast::<*mut u8>();
let l4 = *arg0.add(12).cast::<usize>();
let len5 = l4;
let l6 = *arg0.add(16).cast::<*mut u8>();
let l7 = *arg0.add(20).cast::<usize>();
let len8 = l7;
let l9 = *arg0.add(24).cast::<*mut u8>();
let l10 = *arg0.add(28).cast::<usize>();
let len11 = l10;
let l12 = *arg0.add(32).cast::<*mut u8>();
let l13 = *arg0.add(36).cast::<usize>();
let base17 = l12;
let len17 = l13;
let mut result17 = _rt::Vec::with_capacity(len17);
for i in 0..len17 {
  let base = base17.add(i * 8);
  let e17 = {
    let l14 = *base.add(0).cast::<*mut u8>();
    let l15 = *base.add(4).cast::<usize>();
    let len16 = l15;

    _rt::Vec::from_raw_parts(l14.cast(), len16, len16)
  };
  result17.push(e17);
}
_rt::cabi_dealloc(base17, len17 * 8, 4);
let l18 = *arg0.add(40).cast::<*mut u8>();
let l19 = *arg0.add(44).cast::<usize>();
let len20 = l19;
let l21 = *arg0.add(48).cast::<*mut u8>();
let l22 = *arg0.add(52).cast::<usize>();
let len23 = l22;
let l24 = *arg0.add(56).cast::<*mut u8>();
let l25 = *arg0.add(60).cast::<usize>();
let len26 = l25;
let l27 = *arg0.add(64).cast::<*mut u8>();
let l28 = *arg0.add(68).cast::<usize>();
let len29 = l28;
let l30 = i32::from(*arg0.add(72).cast::<u8>());
let l34 = *arg0.add(84).cast::<*mut u8>();
let l35 = *arg0.add(88).cast::<usize>();
let len36 = l35;
let l37 = *arg0.add(92).cast::<*mut u8>();
let l38 = *arg0.add(96).cast::<usize>();
let len39 = l38;
let l40 = *arg0.add(100).cast::<*mut u8>();
let l41 = *arg0.add(104).cast::<usize>();
let len42 = l41;
let l43 = *arg0.add(108).cast::<*mut u8>();
let l44 = *arg0.add(112).cast::<usize>();
let len45 = l44;
let l46 = *arg0.add(116).cast::<*mut u8>();
let l47 = *arg0.add(120).cast::<usize>();
let base51 = l46;
let len51 = l47;
let mut result51 = _rt::Vec::with_capacity(len51);
for i in 0..len51 {
  let base = base51.add(i * 8);
  let e51 = {
    let l48 = *base.add(0).cast::<*mut u8>();
    let l49 = *base.add(4).cast::<usize>();
    let len50 = l49;

    _rt::Vec::from_raw_parts(l48.cast(), len50, len50)
  };
  result51.push(e51);
}
_rt::cabi_dealloc(base51, len51 * 8, 4);
let l52 = *arg0.add(124).cast::<*mut u8>();
let l53 = *arg0.add(128).cast::<usize>();
let base57 = l52;
let len57 = l53;
let mut result57 = _rt::Vec::with_capacity(len57);
for i in 0..len57 {
  let base = base57.add(i * 8);
  let e57 = {
    let l54 = *base.add(0).cast::<*mut u8>();
    let l55 = *base.add(4).cast::<usize>();
    let len56 = l55;

    _rt::Vec::from_raw_parts(l54.cast(), len56, len56)
  };
  result57.push(e57);
}
_rt::cabi_dealloc(base57, len57 * 8, 4);
let l58 = *arg0.add(132).cast::<*mut u8>();
let l59 = *arg0.add(136).cast::<usize>();
let base68 = l58;
let len68 = l59;
let mut result68 = _rt::Vec::with_capacity(len68);
for i in 0..len68 {
  let base = base68.add(i * 12);
  let e68 = {
    let l60 = i32::from(*base.add(0).cast::<u8>());
    use super::super::super::super::delano::wallet::types::VkCompressed as V67;
    let v67 = match l60 {
      0 => {
        let e67 = {
          let l61 = *base.add(4).cast::<*mut u8>();
          let l62 = *base.add(8).cast::<usize>();
          let len63 = l62;

          _rt::Vec::from_raw_parts(l61.cast(), len63, len63)
        };
        V67::G1(e67)
      }
      n => {
        debug_assert_eq!(n, 1, "invalid enum discriminant");
        let e67 = {
          let l64 = *base.add(4).cast::<*mut u8>();
          let l65 = *base.add(8).cast::<usize>();
          let len66 = l65;

          _rt::Vec::from_raw_parts(l64.cast(), len66, len66)
        };
        V67::G2(e67)
      }
    };

    v67
  };
  result68.push(e68);
}
_rt::cabi_dealloc(base68, len68 * 12, 4);
let l69 = i32::from(*arg0.add(140).cast::<u8>());
let l73 = *arg0.add(152).cast::<*mut u8>();
let l74 = *arg0.add(156).cast::<usize>();
let base81 = l73;
let len81 = l74;
let mut result81 = _rt::Vec::with_capacity(len81);
for i in 0..len81 {
  let base = base81.add(i * 8);
  let e81 = {
    let l75 = *base.add(0).cast::<*mut u8>();
    let l76 = *base.add(4).cast::<usize>();
    let base80 = l75;
    let len80 = l76;
    let mut result80 = _rt::Vec::with_capacity(len80);
    for i in 0..len80 {
      let base = base80.add(i * 8);
      let e80 = {
        let l77 = *base.add(0).cast::<*mut u8>();
        let l78 = *base.add(4).cast::<usize>();
        let len79 = l78;

        _rt::Vec::from_raw_parts(l77.cast(), len79, len79)
      };
      result80.push(e80);
    }
    _rt::cabi_dealloc(base80, len80 * 8, 4);

    result80
  };
  result81.push(e81);
}
_rt::cabi_dealloc(base81, len81 * 8, 4);
let result82 = T::verify(super::super::super::super::delano::wallet::types::Verifiables{
  proof: super::super::super::super::delano::wallet::types::CredProofCompressed{
    sigma: super::super::super::super::delano::wallet::types::SignatureCompressed{
      z: _rt::Vec::from_raw_parts(l0.cast(), len2, len2),
      y_g1: _rt::Vec::from_raw_parts(l3.cast(), len5, len5),
      y_hat: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
      t: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
    },
    commitment_vector: result17,
    witness_pi: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
    nym_proof: super::super::super::super::delano::wallet::types::NymProofCompressed{
      challenge: _rt::Vec::from_raw_parts(l21.cast(), len23, len23),
      pedersen_open: super::super::super::super::delano::wallet::types::PedersenOpenCompressed{
        open_randomness: _rt::Vec::from_raw_parts(l24.cast(), len26, len26),
        announce_randomness: _rt::Vec::from_raw_parts(l27.cast(), len29, len29),
        announce_element: match l30 {
          0 => None,
          1 => {
            let e = {
              let l31 = *arg0.add(76).cast::<*mut u8>();
              let l32 = *arg0.add(80).cast::<usize>();
              let len33 = l32;

              _rt::Vec::from_raw_parts(l31.cast(), len33, len33)
            };
            Some(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        },
      },
      pedersen_commit: _rt::Vec::from_raw_parts(l34.cast(), len36, len36),
      public_key: _rt::Vec::from_raw_parts(l37.cast(), len39, len39),
      response: _rt::Vec::from_raw_parts(l40.cast(), len42, len42),
      damgard: super::super::super::super::delano::wallet::types::DamgardTransformCompressed{
        pedersen: super::super::super::super::delano::wallet::types::PedersenCompressed{
          h: _rt::Vec::from_raw_parts(l43.cast(), len45, len45),
        },
      },
    },
  },
  issuer_public: super::super::super::super::delano::wallet::types::IssuerPublicCompressed{
    parameters: super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{
      pp_commit_g1: result51,
      pp_commit_g2: result57,
    },
    vk: result68,
  },
  nonce: match l69 {
    0 => None,
    1 => {
      let e = {
        let l70 = *arg0.add(144).cast::<*mut u8>();
        let l71 = *arg0.add(148).cast::<usize>();
        let len72 = l71;

        _rt::Vec::from_raw_parts(l70.cast(), len72, len72)
      };
      Some(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  },
  selected: result81,
});
_rt::cabi_dealloc(arg0, 160, 4);
let ptr83 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result82 {
  Ok(e) => { {
    *ptr83.add(0).cast::<u8>() = (0i32) as u8;
    *ptr83.add(4).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
  } },
  Err(e) => { {
    *ptr83.add(0).cast::<u8>() = (1i32) as u8;
    let vec84 = (e.into_bytes()).into_boxed_slice();
    let ptr84 = vec84.as_ptr().cast::<u8>();
    let len84 = vec84.len();
    ::core::mem::forget(vec84);
    *ptr83.add(8).cast::<usize>() = len84;
    *ptr83.add(4).cast::<*mut u8>() = ptr84.cast_mut();
  } },
};ptr83
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_verify<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_issuer_public_cabi<T: Guest>() -> *mut u8 {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = T::issuer_public();
let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
match result0 {
  Ok(e) => { {
    *ptr1.add(0).cast::<u8>() = (0i32) as u8;
    let super::super::super::super::delano::wallet::types::IssuerPublicCompressed{ parameters:parameters2, vk:vk2, } = e;
    let super::super::super::super::delano::wallet::types::ParamSetCommitmentCompressed{ pp_commit_g1:pp_commit_g13, pp_commit_g2:pp_commit_g23, } = parameters2;
    let vec5 = pp_commit_g13;
    let len5 = vec5.len();
    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 8, 4);
    let result5 = if layout5.size() != 0 {
      let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout5);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec5.into_iter().enumerate() {
      let base = result5.add(i * 8);
      {
        let vec4 = (e).into_boxed_slice();
        let ptr4 = vec4.as_ptr().cast::<u8>();
        let len4 = vec4.len();
        ::core::mem::forget(vec4);
        *base.add(4).cast::<usize>() = len4;
        *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
      }
    }
    *ptr1.add(8).cast::<usize>() = len5;
    *ptr1.add(4).cast::<*mut u8>() = result5;
    let vec7 = pp_commit_g23;
    let len7 = vec7.len();
    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 8, 4);
    let result7 = if layout7.size() != 0 {
      let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout7);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec7.into_iter().enumerate() {
      let base = result7.add(i * 8);
      {
        let vec6 = (e).into_boxed_slice();
        let ptr6 = vec6.as_ptr().cast::<u8>();
        let len6 = vec6.len();
        ::core::mem::forget(vec6);
        *base.add(4).cast::<usize>() = len6;
        *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
      }
    }
    *ptr1.add(16).cast::<usize>() = len7;
    *ptr1.add(12).cast::<*mut u8>() = result7;
    let vec11 = vk2;
    let len11 = vec11.len();
    let layout11 = _rt::alloc::Layout::from_size_align_unchecked(vec11.len() * 12, 4);
    let result11 = if layout11.size() != 0 {
      let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
      if ptr.is_null()
      {
        _rt::alloc::handle_alloc_error(layout11);
      }
      ptr
    }else {
      ::core::ptr::null_mut()
    };
    for (i, e) in vec11.into_iter().enumerate() {
      let base = result11.add(i * 12);
      {
        use super::super::super::super::delano::wallet::types::VkCompressed as V10;
        match e {
          V10::G1(e) => {
            *base.add(0).cast::<u8>() = (0i32) as u8;
            let vec8 = (e).into_boxed_slice();
            let ptr8 = vec8.as_ptr().cast::<u8>();
            let len8 = vec8.len();
            ::core::mem::forget(vec8);
            *base.add(8).cast::<usize>() = len8;
            *base.add(4).cast::<*mut u8>() = ptr8.cast_mut();
          },
          V10::G2(e) => {
            *base.add(0).cast::<u8>() = (1i32) as u8;
            let vec9 = (e).into_boxed_slice();
            let ptr9 = vec9.as_ptr().cast::<u8>();
            let len9 = vec9.len();
            ::core::mem::forget(vec9);
            *base.add(8).cast::<usize>() = len9;
            *base.add(4).cast::<*mut u8>() = ptr9.cast_mut();
          },
        }
      }
    }
    *ptr1.add(24).cast::<usize>() = len11;
    *ptr1.add(20).cast::<*mut u8>() = result11;
  } },
  Err(e) => { {
    *ptr1.add(0).cast::<u8>() = (1i32) as u8;
    let vec12 = (e.into_bytes()).into_boxed_slice();
    let ptr12 = vec12.as_ptr().cast::<u8>();
    let len12 = vec12.len();
    ::core::mem::forget(vec12);
    *ptr1.add(8).cast::<usize>() = len12;
    *ptr1.add(4).cast::<*mut u8>() = ptr12.cast_mut();
  } },
};ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_issuer_public<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      let base6 = l1;
      let len6 = l2;
      for i in 0..len6 {
        let base = base6.add(i * 8);
        {
          let l3 = *base.add(0).cast::<*mut u8>();
          let l4 = *base.add(4).cast::<usize>();
          let base5 = l3;
          let len5 = l4;
          _rt::cabi_dealloc(base5, len5 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base6, len6 * 8, 4);
      let l7 = *arg0.add(12).cast::<*mut u8>();
      let l8 = *arg0.add(16).cast::<usize>();
      let base12 = l7;
      let len12 = l8;
      for i in 0..len12 {
        let base = base12.add(i * 8);
        {
          let l9 = *base.add(0).cast::<*mut u8>();
          let l10 = *base.add(4).cast::<usize>();
          let base11 = l9;
          let len11 = l10;
          _rt::cabi_dealloc(base11, len11 * 1, 1);
        }
      }
      _rt::cabi_dealloc(base12, len12 * 8, 4);
      let l13 = *arg0.add(20).cast::<*mut u8>();
      let l14 = *arg0.add(24).cast::<usize>();
      let base22 = l13;
      let len22 = l14;
      for i in 0..len22 {
        let base = base22.add(i * 12);
        {
          let l15 = i32::from(*base.add(0).cast::<u8>());
          match l15 {
            0 => {
              let l16 = *base.add(4).cast::<*mut u8>();
              let l17 = *base.add(8).cast::<usize>();
              let base18 = l16;
              let len18 = l17;
              _rt::cabi_dealloc(base18, len18 * 1, 1);
            },
            _ => {
              let l19 = *base.add(4).cast::<*mut u8>();
              let l20 = *base.add(8).cast::<usize>();
              let base21 = l19;
              let len21 = l20;
              _rt::cabi_dealloc(base21, len21 * 1, 1);
            },
          }
        }
      }
      _rt::cabi_dealloc(base22, len22 * 12, 4);
    },
    _ => {
      let l23 = *arg0.add(4).cast::<*mut u8>();
      let l24 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l23, l24, 1);
    },
  }
}
pub trait Guest {
  /// Returns the active Nym of the component.
  fn get_nym_proof(nonce: _rt::Vec::<u8>,) -> Result<NymProofCompressed,_rt::String>;
  /// Issue a credential Entry to a Nym with maximum entries.
  /// By default issues a credential to your own Nym. To issue to others, set the options to their nymproof and optionally the nonce you gave them.
  fn issue(attributes: _rt::Vec::<Attribute>,maxentries: u8,options: Option<IssueOptions>,) -> Result<CredentialCompressed,_rt::String>;
  /// Create an offer for a credential with its given entries and a given configuration.
  fn offer(cred: CredentialCompressed,config: OfferConfig,) -> Result<CredentialCompressed,_rt::String>;
  /// Accept a credential offer and return the accepte Credential bytes
  fn accept(offer: CredentialCompressed,) -> Result<CredentialCompressed,_rt::String>;
  /// Extend a credential with a new entry
  fn extend(cred: CredentialCompressed,entry: Entry,) -> Result<CredentialCompressed,_rt::String>;
  /// Export a function that proves selected attributes in a given credential
  /// Returns the selected attributes in the proper order in order to verify the proof,
  /// as each Attribute needs to be verified from their respective Entry.
  fn prove(values: Provables,) -> Result<Proven,_rt::String>;
  /// Export a function that verifies a proof against a public key, nonce and selected attributes
  fn verify(values: Verifiables,) -> Result<bool,_rt::String>;
  /// Returns the Issuer's public key if it exists, otherwise returns an error.
  fn issuer_public() -> Result<IssuerPublicCompressed,_rt::String>;
}
#[doc(hidden)]

macro_rules! __export_delano_wallet_actions_0_1_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "delano:wallet/actions@0.1.0#get-nym-proof"]
    unsafe extern "C" fn export_get_nym_proof(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_get_nym_proof_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#get-nym-proof"]
    unsafe extern "C" fn _post_return_get_nym_proof(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_get_nym_proof::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#issue"]
    unsafe extern "C" fn export_issue(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_issue_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#issue"]
    unsafe extern "C" fn _post_return_issue(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_issue::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#offer"]
    unsafe extern "C" fn export_offer(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_offer_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#offer"]
    unsafe extern "C" fn _post_return_offer(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_offer::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#accept"]
    unsafe extern "C" fn export_accept(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_accept_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#accept"]
    unsafe extern "C" fn _post_return_accept(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_accept::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#extend"]
    unsafe extern "C" fn export_extend(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_extend_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#extend"]
    unsafe extern "C" fn _post_return_extend(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_extend::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#prove"]
    unsafe extern "C" fn export_prove(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_prove_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#prove"]
    unsafe extern "C" fn _post_return_prove(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_prove::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#verify"]
    unsafe extern "C" fn export_verify(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_verify_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#verify"]
    unsafe extern "C" fn _post_return_verify(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_verify::<$ty>(arg0)
    }
    #[export_name = "delano:wallet/actions@0.1.0#issuer-public"]
    unsafe extern "C" fn export_issuer_public() -> *mut u8 {
      $($path_to_types)*::_export_issuer_public_cabi::<$ty>()
    }
    #[export_name = "cabi_post_delano:wallet/actions@0.1.0#issuer-public"]
    unsafe extern "C" fn _post_return_issuer_public(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_issuer_public::<$ty>(arg0)
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_delano_wallet_actions_0_1_0_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 128]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 128]);

}

}
}
}
mod _rt {
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::string::String;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen_rt::run_ctors_once();
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    let layout = alloc::Layout::from_size_align_unchecked(size, align);
    alloc::dealloc(ptr, layout);
  }
  pub use alloc_crate::alloc;
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_delanocreds_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::delano::wallet::actions::__export_delano_wallet_actions_0_1_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::delano::wallet::actions);
  )
}
#[doc(inline)]
pub(crate) use __export_delanocreds_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.35.0:delano:wallet@0.1.0:delanocreds:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2060] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8a\x0f\x01A\x02\x01\
A\x11\x01B\x04\x01p}\x01j\x01\0\x01s\x01@\0\0\x01\x04\0\x08get-seed\x01\x02\x03\0\
\x1fseed-keeper:wallet/config@0.1.0\x05\0\x01B5\x01p}\x04\0\x09attribute\x03\0\0\
\x01p\x01\x04\0\x05entry\x03\0\x02\x01p}\x04\0\x05nonce\x03\0\x04\x01p}\x04\0\x05\
proof\x03\0\x06\x01p\x03\x04\0\x08selected\x03\0\x08\x01p\x03\x01p\x01\x01r\x02\x07\
entries\x0a\x06remove\x0b\x04\0\x0bredactables\x03\0\x0c\x01k\x0d\x01k\x03\x01k}\
\x01r\x03\x06redact\x0e\x10additional-entry\x0f\x0bmax-entries\x10\x04\0\x0coffe\
r-config\x03\0\x11\x01p}\x01r\x04\x01z\x13\x04y-g1\x13\x05y-hat\x13\x01t\x13\x04\
\0\x14signature-compressed\x03\0\x14\x01p\x13\x01r\x02\x0cpp-commit-g1\x16\x0cpp\
-commit-g2\x16\x04\0\x1fparam-set-commitment-compressed\x03\0\x17\x01q\x02\x02g1\
\x01\x13\0\x02g2\x01\x13\0\x04\0\x0dvk-compressed\x03\0\x19\x01p\x1a\x01r\x02\x0a\
parameters\x18\x02vk\x1b\x04\0\x18issuer-public-compressed\x03\0\x1c\x01p\x16\x01\
k\x1e\x01r\x05\x05sigma\x15\x0aupdate-key\x1f\x11commitment-vector\x16\x0eopenin\
g-vector\x16\x0dissuer-public\x1d\x04\0\x15credential-compressed\x03\0\x20\x01r\x04\
\x0acredential!\x07entries\x0a\x08selected\x0b\x05nonce\x13\x04\0\x09provables\x03\
\0\"\x01r\x01\x01h\x13\x04\0\x13pedersen-compressed\x03\0$\x01r\x01\x08pedersen%\
\x04\0\x1cdamgard-transform-compressed\x03\0&\x01k\x13\x01r\x03\x0fopen-randomne\
ss\x13\x13announce-randomness\x13\x10announce-element(\x04\0\x18pedersen-open-co\
mpressed\x03\0)\x01r\x06\x09challenge\x13\x0dpedersen-open*\x0fpedersen-commit\x13\
\x0apublic-key\x13\x08response\x13\x07damgard'\x04\0\x14nym-proof-compressed\x03\
\0+\x01r\x02\x08nymproof,\x05nonce(\x04\0\x0dissue-options\x03\0-\x01r\x04\x05si\
gma\x15\x11commitment-vector\x16\x0awitness-pi\x13\x09nym-proof,\x04\0\x15cred-p\
roof-compressed\x03\0/\x01r\x02\x05proof0\x08selected\x09\x04\0\x06proven\x03\01\
\x01r\x04\x05proof0\x0dissuer-public\x1d\x05nonce(\x08selected\x09\x04\0\x0bveri\
fiables\x03\03\x03\0\x19delano:wallet/types@0.1.0\x05\x01\x02\x03\0\x01\x09attri\
bute\x02\x03\0\x01\x09provables\x02\x03\0\x01\x0bverifiables\x02\x03\0\x01\x0cof\
fer-config\x02\x03\0\x01\x0dissue-options\x02\x03\0\x01\x05nonce\x02\x03\0\x01\x05\
entry\x02\x03\0\x01\x06proven\x02\x03\0\x01\x15credential-compressed\x02\x03\0\x01\
\x14nym-proof-compressed\x02\x03\0\x01\x18issuer-public-compressed\x01B.\x02\x03\
\x02\x01\x02\x04\0\x09attribute\x03\0\0\x02\x03\x02\x01\x03\x04\0\x09provables\x03\
\0\x02\x02\x03\x02\x01\x04\x04\0\x0bverifiables\x03\0\x04\x02\x03\x02\x01\x05\x04\
\0\x0coffer-config\x03\0\x06\x02\x03\x02\x01\x06\x04\0\x0dissue-options\x03\0\x08\
\x02\x03\x02\x01\x07\x04\0\x05nonce\x03\0\x0a\x02\x03\x02\x01\x08\x04\0\x05entry\
\x03\0\x0c\x02\x03\x02\x01\x09\x04\0\x06proven\x03\0\x0e\x02\x03\x02\x01\x0a\x04\
\0\x15credential-compressed\x03\0\x10\x02\x03\x02\x01\x0b\x04\0\x14nym-proof-com\
pressed\x03\0\x12\x02\x03\x02\x01\x0c\x04\0\x18issuer-public-compressed\x03\0\x14\
\x01p}\x01j\x01\x13\x01s\x01@\x01\x05nonce\x16\0\x17\x04\0\x0dget-nym-proof\x01\x18\
\x01p\x01\x01k\x09\x01j\x01\x11\x01s\x01@\x03\x0aattributes\x19\x0amaxentries}\x07\
options\x1a\0\x1b\x04\0\x05issue\x01\x1c\x01@\x02\x04cred\x11\x06config\x07\0\x1b\
\x04\0\x05offer\x01\x1d\x01@\x01\x05offer\x11\0\x1b\x04\0\x06accept\x01\x1e\x01@\
\x02\x04cred\x11\x05entry\x0d\0\x1b\x04\0\x06extend\x01\x1f\x01j\x01\x0f\x01s\x01\
@\x01\x06values\x03\0\x20\x04\0\x05prove\x01!\x01j\x01\x7f\x01s\x01@\x01\x06valu\
es\x05\0\"\x04\0\x06verify\x01#\x01j\x01\x15\x01s\x01@\0\0$\x04\0\x0dissuer-publ\
ic\x01%\x04\0\x1bdelano:wallet/actions@0.1.0\x05\x0d\x04\0\x1fdelano:wallet/dela\
nocreds@0.1.0\x04\0\x0b\x11\x01\0\x0bdelanocreds\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.220.0\x10wit-bindgen-rust\x060.35.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen_rt::maybe_link_cabi_realloc();
}

