// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
pub mod delano {
  pub mod wallet {
    
    #[allow(clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// An attribute is a 32 bytes hash value
      pub type Attribute = wit_bindgen::rt::vec::Vec::<u8>;
      pub type Entry = wit_bindgen::rt::vec::Vec::<Attribute>;
      pub type Nonce = wit_bindgen::rt::vec::Vec::<u8>;
      pub type Selected = wit_bindgen::rt::vec::Vec::<Entry>;
      #[derive(Clone)]
      pub struct Provables {
        pub credential: wit_bindgen::rt::vec::Vec::<u8>,
        pub entries: wit_bindgen::rt::vec::Vec::<Entry>,
        pub selected: wit_bindgen::rt::vec::Vec::<Attribute>,
        pub nonce: wit_bindgen::rt::vec::Vec::<u8>,
      }
      impl ::core::fmt::Debug for Provables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Provables").field("credential", &self.credential).field("entries", &self.entries).field("selected", &self.selected).field("nonce", &self.nonce).finish()
        }
      }
      #[derive(Clone)]
      pub struct Proven {
        pub proof: wit_bindgen::rt::vec::Vec::<u8>,
        pub selected: wit_bindgen::rt::vec::Vec::<Entry>,
      }
      impl ::core::fmt::Debug for Proven {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Proven").field("proof", &self.proof).field("selected", &self.selected).finish()
        }
      }
      #[derive(Clone)]
      pub struct Verifiables {
        pub proof: wit_bindgen::rt::vec::Vec::<u8>,
        pub issuer_public: wit_bindgen::rt::vec::Vec::<u8>,
        pub nonce: Option<wit_bindgen::rt::vec::Vec::<u8>>,
        pub selected: Selected,
      }
      impl ::core::fmt::Debug for Verifiables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Verifiables").field("proof", &self.proof).field("issuer-public", &self.issuer_public).field("nonce", &self.nonce).field("selected", &self.selected).finish()
        }
      }
      /// Issuer config: Default config creates (issues) a credential to yourself.
      /// Provide a config to offer it to someone else's nym, and optionally verify it with a nonce.
      #[derive(Clone)]
      pub struct IssueOptions {
        pub nymproof: wit_bindgen::rt::vec::Vec::<u8>,
        pub nonce: Option<wit_bindgen::rt::vec::Vec::<u8>>,
      }
      impl ::core::fmt::Debug for IssueOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("IssueOptions").field("nymproof", &self.nymproof).field("nonce", &self.nonce).finish()
        }
      }
      /// If you want to redact an Entry containing an Attribute,
      /// construct a redactable record with all Entries and the list of Attributes to redact.
      #[derive(Clone)]
      pub struct Redactables {
        pub entries: wit_bindgen::rt::vec::Vec::<Entry>,
        pub remove: wit_bindgen::rt::vec::Vec::<Attribute>,
      }
      impl ::core::fmt::Debug for Redactables {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Redactables").field("entries", &self.entries).field("remove", &self.remove).finish()
        }
      }
      /// Configuration of an Offer. Can set 3 things:
      /// 1) without-attribute: an optional redactable record of attributes to redact,
      /// 2) additional-entry: an optional single additional entry,
      /// 3) max-entries: the maximum number of entries the delegated party can add to the credential.
      #[derive(Clone)]
      pub struct OfferConfig {
        pub redact: Option<Redactables>,
        pub additional_entry: Option<Entry>,
        /// Optionally reduces the number of entries that can be added to the credential.
        pub max_entries: Option<u8>,
      }
      impl ::core::fmt::Debug for OfferConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OfferConfig").field("redact", &self.redact).field("additional-entry", &self.additional_entry).field("max-entries", &self.max_entries).finish()
        }
      }
      
    }
    
  }
}
pub mod seed_keeper {
  pub mod wallet {
    
    #[allow(clippy::all)]
    pub mod config {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the plaintext seed
      pub fn get_seed() -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let ptr0 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "seed-keeper:wallet/config@0.1.0")]
          extern "C" {
            #[link_name = "get-seed"]
            fn wit_import(_: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*((ptr0 + 0) as *const u8));
          match l1 {
            0 => {
              let e = {
                let l2 = *((ptr0 + 4) as *const i32);
                let l3 = *((ptr0 + 8) as *const i32);
                let len4 = l3 as usize;
                
                Vec::from_raw_parts(l2 as *mut _, len4, len4)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *((ptr0 + 4) as *const i32);
                let l6 = *((ptr0 + 8) as *const i32);
                let len7 = l6 as usize;
                let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                
                wit_bindgen::rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
  }
}
pub mod exports {
  pub mod delano {
    pub mod wallet {
      
      #[allow(clippy::all)]
      pub mod actions {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
        pub type Attribute = super::super::super::super::delano::wallet::types::Attribute;
        pub type Provables = super::super::super::super::delano::wallet::types::Provables;
        pub type Verifiables = super::super::super::super::delano::wallet::types::Verifiables;
        pub type OfferConfig = super::super::super::super::delano::wallet::types::OfferConfig;
        pub type IssueOptions = super::super::super::super::delano::wallet::types::IssueOptions;
        pub type Nonce = super::super::super::super::delano::wallet::types::Nonce;
        pub type Entry = super::super::super::super::delano::wallet::types::Entry;
        pub type Proven = super::super::super::super::delano::wallet::types::Proven;
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#get-nym-proof"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_get_nym_proof(arg0: i32,arg1: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let result1 = <_GuestImpl as Guest>::get_nym_proof(Vec::from_raw_parts(arg0 as *mut _, len0, len0));
            let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
            match result1 {
              Ok(e) => { {
                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                let vec3 = (e).into_boxed_slice();
                let ptr3 = vec3.as_ptr() as i32;
                let len3 = vec3.len() as i32;
                ::core::mem::forget(vec3);
                *((ptr2 + 8) as *mut i32) = len3;
                *((ptr2 + 4) as *mut i32) = ptr3;
              } },
              Err(e) => { {
                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                let vec4 = (e.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr() as i32;
                let len4 = vec4.len() as i32;
                ::core::mem::forget(vec4);
                *((ptr2 + 8) as *mut i32) = len4;
                *((ptr2 + 4) as *mut i32) = ptr4;
              } },
            };ptr2
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#get-nym-proof"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_get_nym_proof(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                },
                _ => {
                  let l4 = *((arg0 + 4) as *const i32);
                  let l5 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#issue"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_issue(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let base3 = arg0;
            let len3 = arg1;
            let mut result3 = Vec::with_capacity(len3 as usize);
            for i in 0..len3 {
              let base = base3 + i * 8;
              let e3 = {
                let l0 = *((base + 0) as *const i32);
                let l1 = *((base + 4) as *const i32);
                let len2 = l1 as usize;
                
                Vec::from_raw_parts(l0 as *mut _, len2, len2)
              };
              result3.push(e3);
            }
            wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
            let result6 = <_GuestImpl as Guest>::issue(result3, arg2 as u8, match arg3 {
              0 => None,
              1 => {
                let e = {
                  let len4 = arg5 as usize;
                  
                  super::super::super::super::delano::wallet::types::IssueOptions{
                    nymproof: Vec::from_raw_parts(arg4 as *mut _, len4, len4),
                    nonce: match arg6 {
                      0 => None,
                      1 => {
                        let e = {
                          let len5 = arg8 as usize;
                          
                          Vec::from_raw_parts(arg7 as *mut _, len5, len5)
                        };
                        Some(e)
                      }
                      _ => wit_bindgen::rt::invalid_enum_discriminant(),
                    },
                  }
                };
                Some(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            });
            let ptr7 = _RET_AREA.0.as_mut_ptr() as i32;
            match result6 {
              Ok(e) => { {
                *((ptr7 + 0) as *mut u8) = (0i32) as u8;
                let vec8 = (e).into_boxed_slice();
                let ptr8 = vec8.as_ptr() as i32;
                let len8 = vec8.len() as i32;
                ::core::mem::forget(vec8);
                *((ptr7 + 8) as *mut i32) = len8;
                *((ptr7 + 4) as *mut i32) = ptr8;
              } },
              Err(e) => { {
                *((ptr7 + 0) as *mut u8) = (1i32) as u8;
                let vec9 = (e.into_bytes()).into_boxed_slice();
                let ptr9 = vec9.as_ptr() as i32;
                let len9 = vec9.len() as i32;
                ::core::mem::forget(vec9);
                *((ptr7 + 8) as *mut i32) = len9;
                *((ptr7 + 4) as *mut i32) = ptr9;
              } },
            };ptr7
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#issue"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_issue(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                },
                _ => {
                  let l4 = *((arg0 + 4) as *const i32);
                  let l5 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#offer"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_offer(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let result16 = <_GuestImpl as Guest>::offer(Vec::from_raw_parts(arg0 as *mut _, len0, len0), super::super::super::super::delano::wallet::types::OfferConfig{
              redact: match arg2 {
                0 => None,
                1 => {
                  let e = {
                    let base7 = arg3;
                    let len7 = arg4;
                    let mut result7 = Vec::with_capacity(len7 as usize);
                    for i in 0..len7 {
                      let base = base7 + i * 8;
                      let e7 = {
                        let l1 = *((base + 0) as *const i32);
                        let l2 = *((base + 4) as *const i32);
                        let base6 = l1;
                        let len6 = l2;
                        let mut result6 = Vec::with_capacity(len6 as usize);
                        for i in 0..len6 {
                          let base = base6 + i * 8;
                          let e6 = {
                            let l3 = *((base + 0) as *const i32);
                            let l4 = *((base + 4) as *const i32);
                            let len5 = l4 as usize;
                            
                            Vec::from_raw_parts(l3 as *mut _, len5, len5)
                          };
                          result6.push(e6);
                        }
                        wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                        
                        result6
                      };
                      result7.push(e7);
                    }
                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);
                    let base11 = arg5;
                    let len11 = arg6;
                    let mut result11 = Vec::with_capacity(len11 as usize);
                    for i in 0..len11 {
                      let base = base11 + i * 8;
                      let e11 = {
                        let l8 = *((base + 0) as *const i32);
                        let l9 = *((base + 4) as *const i32);
                        let len10 = l9 as usize;
                        
                        Vec::from_raw_parts(l8 as *mut _, len10, len10)
                      };
                      result11.push(e11);
                    }
                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                    
                    super::super::super::super::delano::wallet::types::Redactables{
                      entries: result7,
                      remove: result11,
                    }
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              additional_entry: match arg7 {
                0 => None,
                1 => {
                  let e = {
                    let base15 = arg8;
                    let len15 = arg9;
                    let mut result15 = Vec::with_capacity(len15 as usize);
                    for i in 0..len15 {
                      let base = base15 + i * 8;
                      let e15 = {
                        let l12 = *((base + 0) as *const i32);
                        let l13 = *((base + 4) as *const i32);
                        let len14 = l13 as usize;
                        
                        Vec::from_raw_parts(l12 as *mut _, len14, len14)
                      };
                      result15.push(e15);
                    }
                    wit_bindgen::rt::dealloc(base15, (len15 as usize) * 8, 4);
                    
                    result15
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              max_entries: match arg10 {
                0 => None,
                1 => {
                  let e = arg11 as u8;
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
            });
            let ptr17 = _RET_AREA.0.as_mut_ptr() as i32;
            match result16 {
              Ok(e) => { {
                *((ptr17 + 0) as *mut u8) = (0i32) as u8;
                let vec18 = (e).into_boxed_slice();
                let ptr18 = vec18.as_ptr() as i32;
                let len18 = vec18.len() as i32;
                ::core::mem::forget(vec18);
                *((ptr17 + 8) as *mut i32) = len18;
                *((ptr17 + 4) as *mut i32) = ptr18;
              } },
              Err(e) => { {
                *((ptr17 + 0) as *mut u8) = (1i32) as u8;
                let vec19 = (e.into_bytes()).into_boxed_slice();
                let ptr19 = vec19.as_ptr() as i32;
                let len19 = vec19.len() as i32;
                ::core::mem::forget(vec19);
                *((ptr17 + 8) as *mut i32) = len19;
                *((ptr17 + 4) as *mut i32) = ptr19;
              } },
            };ptr17
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#offer"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_offer(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                },
                _ => {
                  let l4 = *((arg0 + 4) as *const i32);
                  let l5 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#accept"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_accept(arg0: i32,arg1: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let result1 = <_GuestImpl as Guest>::accept(Vec::from_raw_parts(arg0 as *mut _, len0, len0));
            let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
            match result1 {
              Ok(e) => { {
                *((ptr2 + 0) as *mut u8) = (0i32) as u8;
                let vec3 = (e).into_boxed_slice();
                let ptr3 = vec3.as_ptr() as i32;
                let len3 = vec3.len() as i32;
                ::core::mem::forget(vec3);
                *((ptr2 + 8) as *mut i32) = len3;
                *((ptr2 + 4) as *mut i32) = ptr3;
              } },
              Err(e) => { {
                *((ptr2 + 0) as *mut u8) = (1i32) as u8;
                let vec4 = (e.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr() as i32;
                let len4 = vec4.len() as i32;
                ::core::mem::forget(vec4);
                *((ptr2 + 8) as *mut i32) = len4;
                *((ptr2 + 4) as *mut i32) = ptr4;
              } },
            };ptr2
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#accept"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_accept(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                },
                _ => {
                  let l4 = *((arg0 + 4) as *const i32);
                  let l5 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#extend"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_extend(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let base4 = arg2;
            let len4 = arg3;
            let mut result4 = Vec::with_capacity(len4 as usize);
            for i in 0..len4 {
              let base = base4 + i * 8;
              let e4 = {
                let l1 = *((base + 0) as *const i32);
                let l2 = *((base + 4) as *const i32);
                let len3 = l2 as usize;
                
                Vec::from_raw_parts(l1 as *mut _, len3, len3)
              };
              result4.push(e4);
            }
            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
            let result5 = <_GuestImpl as Guest>::extend(Vec::from_raw_parts(arg0 as *mut _, len0, len0), result4);
            let ptr6 = _RET_AREA.0.as_mut_ptr() as i32;
            match result5 {
              Ok(e) => { {
                *((ptr6 + 0) as *mut u8) = (0i32) as u8;
                let vec7 = (e).into_boxed_slice();
                let ptr7 = vec7.as_ptr() as i32;
                let len7 = vec7.len() as i32;
                ::core::mem::forget(vec7);
                *((ptr6 + 8) as *mut i32) = len7;
                *((ptr6 + 4) as *mut i32) = ptr7;
              } },
              Err(e) => { {
                *((ptr6 + 0) as *mut u8) = (1i32) as u8;
                let vec8 = (e.into_bytes()).into_boxed_slice();
                let ptr8 = vec8.as_ptr() as i32;
                let len8 = vec8.len() as i32;
                ::core::mem::forget(vec8);
                *((ptr6 + 8) as *mut i32) = len8;
                *((ptr6 + 4) as *mut i32) = ptr8;
              } },
            };ptr6
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#extend"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_extend(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                },
                _ => {
                  let l4 = *((arg0 + 4) as *const i32);
                  let l5 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l4, (l5) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#prove"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_prove(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let base7 = arg2;
            let len7 = arg3;
            let mut result7 = Vec::with_capacity(len7 as usize);
            for i in 0..len7 {
              let base = base7 + i * 8;
              let e7 = {
                let l1 = *((base + 0) as *const i32);
                let l2 = *((base + 4) as *const i32);
                let base6 = l1;
                let len6 = l2;
                let mut result6 = Vec::with_capacity(len6 as usize);
                for i in 0..len6 {
                  let base = base6 + i * 8;
                  let e6 = {
                    let l3 = *((base + 0) as *const i32);
                    let l4 = *((base + 4) as *const i32);
                    let len5 = l4 as usize;
                    
                    Vec::from_raw_parts(l3 as *mut _, len5, len5)
                  };
                  result6.push(e6);
                }
                wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                
                result6
              };
              result7.push(e7);
            }
            wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);
            let base11 = arg4;
            let len11 = arg5;
            let mut result11 = Vec::with_capacity(len11 as usize);
            for i in 0..len11 {
              let base = base11 + i * 8;
              let e11 = {
                let l8 = *((base + 0) as *const i32);
                let l9 = *((base + 4) as *const i32);
                let len10 = l9 as usize;
                
                Vec::from_raw_parts(l8 as *mut _, len10, len10)
              };
              result11.push(e11);
            }
            wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
            let len12 = arg7 as usize;
            let result13 = <_GuestImpl as Guest>::prove(super::super::super::super::delano::wallet::types::Provables{
              credential: Vec::from_raw_parts(arg0 as *mut _, len0, len0),
              entries: result7,
              selected: result11,
              nonce: Vec::from_raw_parts(arg6 as *mut _, len12, len12),
            });
            let ptr14 = _RET_AREA.0.as_mut_ptr() as i32;
            match result13 {
              Ok(e) => { {
                *((ptr14 + 0) as *mut u8) = (0i32) as u8;
                let super::super::super::super::delano::wallet::types::Proven{ proof:proof15, selected:selected15, } = e;
                let vec16 = (proof15).into_boxed_slice();
                let ptr16 = vec16.as_ptr() as i32;
                let len16 = vec16.len() as i32;
                ::core::mem::forget(vec16);
                *((ptr14 + 8) as *mut i32) = len16;
                *((ptr14 + 4) as *mut i32) = ptr16;
                let vec19 = selected15;
                let len19 = vec19.len() as i32;
                let layout19 = alloc::Layout::from_size_align_unchecked(vec19.len() * 8, 4);
                let result19 = if layout19.size() != 0
                {
                  let ptr = alloc::alloc(layout19);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout19);
                  }
                  ptr
                }else {{
                  ::core::ptr::null_mut()
                }};
                for (i, e) in vec19.into_iter().enumerate() {
                  let base = result19 as i32 + (i as i32) * 8;
                  {
                    let vec18 = e;
                    let len18 = vec18.len() as i32;
                    let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 8, 4);
                    let result18 = if layout18.size() != 0
                    {
                      let ptr = alloc::alloc(layout18);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout18);
                      }
                      ptr
                    }else {{
                      ::core::ptr::null_mut()
                    }};
                    for (i, e) in vec18.into_iter().enumerate() {
                      let base = result18 as i32 + (i as i32) * 8;
                      {
                        let vec17 = (e).into_boxed_slice();
                        let ptr17 = vec17.as_ptr() as i32;
                        let len17 = vec17.len() as i32;
                        ::core::mem::forget(vec17);
                        *((base + 4) as *mut i32) = len17;
                        *((base + 0) as *mut i32) = ptr17;
                      }
                    }
                    *((base + 4) as *mut i32) = len18;
                    *((base + 0) as *mut i32) = result18 as i32;
                  }
                }
                *((ptr14 + 16) as *mut i32) = len19;
                *((ptr14 + 12) as *mut i32) = result19 as i32;
              } },
              Err(e) => { {
                *((ptr14 + 0) as *mut u8) = (1i32) as u8;
                let vec20 = (e.into_bytes()).into_boxed_slice();
                let ptr20 = vec20.as_ptr() as i32;
                let len20 = vec20.len() as i32;
                ::core::mem::forget(vec20);
                *((ptr14 + 8) as *mut i32) = len20;
                *((ptr14 + 4) as *mut i32) = ptr20;
              } },
            };ptr14
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#prove"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_prove(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  let base3 = l1;
                  let len3 = l2;
                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                  let l10 = *((arg0 + 12) as *const i32);
                  let l11 = *((arg0 + 16) as *const i32);
                  let base12 = l10;
                  let len12 = l11;
                  for i in 0..len12 {
                    let base = base12 + i *8;
                    {
                      let l7 = *((base + 0) as *const i32);
                      let l8 = *((base + 4) as *const i32);
                      let base9 = l7;
                      let len9 = l8;
                      for i in 0..len9 {
                        let base = base9 + i *8;
                        {
                          let l4 = *((base + 0) as *const i32);
                          let l5 = *((base + 4) as *const i32);
                          let base6 = l4;
                          let len6 = l5;
                          wit_bindgen::rt::dealloc(base6, (len6 as usize) * 1, 1);
                        }
                      }
                      wit_bindgen::rt::dealloc(base9, (len9 as usize) * 8, 4);
                    }
                  }
                  wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
                },
                _ => {
                  let l13 = *((arg0 + 4) as *const i32);
                  let l14 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l13, (l14) as usize, 1);
                },
              }
            }
          };
        };
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "delano:wallet/actions@0.1.0#verify"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_verify(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg1 as usize;
            let len1 = arg3 as usize;
            let base9 = arg7;
            let len9 = arg8;
            let mut result9 = Vec::with_capacity(len9 as usize);
            for i in 0..len9 {
              let base = base9 + i * 8;
              let e9 = {
                let l3 = *((base + 0) as *const i32);
                let l4 = *((base + 4) as *const i32);
                let base8 = l3;
                let len8 = l4;
                let mut result8 = Vec::with_capacity(len8 as usize);
                for i in 0..len8 {
                  let base = base8 + i * 8;
                  let e8 = {
                    let l5 = *((base + 0) as *const i32);
                    let l6 = *((base + 4) as *const i32);
                    let len7 = l6 as usize;
                    
                    Vec::from_raw_parts(l5 as *mut _, len7, len7)
                  };
                  result8.push(e8);
                }
                wit_bindgen::rt::dealloc(base8, (len8 as usize) * 8, 4);
                
                result8
              };
              result9.push(e9);
            }
            wit_bindgen::rt::dealloc(base9, (len9 as usize) * 8, 4);
            let result10 = <_GuestImpl as Guest>::verify(super::super::super::super::delano::wallet::types::Verifiables{
              proof: Vec::from_raw_parts(arg0 as *mut _, len0, len0),
              issuer_public: Vec::from_raw_parts(arg2 as *mut _, len1, len1),
              nonce: match arg4 {
                0 => None,
                1 => {
                  let e = {
                    let len2 = arg6 as usize;
                    
                    Vec::from_raw_parts(arg5 as *mut _, len2, len2)
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              selected: result9,
            });
            let ptr11 = _RET_AREA.0.as_mut_ptr() as i32;
            match result10 {
              Ok(e) => { {
                *((ptr11 + 0) as *mut u8) = (0i32) as u8;
                *((ptr11 + 4) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
              } },
              Err(e) => { {
                *((ptr11 + 0) as *mut u8) = (1i32) as u8;
                let vec12 = (e.into_bytes()).into_boxed_slice();
                let ptr12 = vec12.as_ptr() as i32;
                let len12 = vec12.len() as i32;
                ::core::mem::forget(vec12);
                *((ptr11 + 8) as *mut i32) = len12;
                *((ptr11 + 4) as *mut i32) = ptr12;
              } },
            };ptr11
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_delano:wallet/actions@0.1.0#verify"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_verify(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 0) as *const u8));
              match l0 {
                0 => (),
                _ => {
                  let l1 = *((arg0 + 4) as *const i32);
                  let l2 = *((arg0 + 8) as *const i32);
                  wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                },
              }
            }
          };
        };
        use super::super::super::super::super::Component as _GuestImpl;
        pub trait Guest {
          /// Returns the active Nym of the component.
          fn get_nym_proof(nonce: Nonce,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>;
          /// Issue a credential Entry to a Nym with maximum entries.
          /// By default issues a credential to your own Nym. To issue to others, set the options to their nymproof and optionally the nonce you gave them.
          fn issue(attributes: wit_bindgen::rt::vec::Vec::<Attribute>,maxentries: u8,options: Option<IssueOptions>,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>;
          /// Create an offer for a credential with its given entries and a given configuration.
          fn offer(cred: wit_bindgen::rt::vec::Vec::<u8>,config: OfferConfig,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>;
          /// Accept a credential offer and return the accepte Credential bytes
          fn accept(offer: wit_bindgen::rt::vec::Vec::<u8>,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>;
          /// Extend a credential with a new entry
          fn extend(cred: wit_bindgen::rt::vec::Vec::<u8>,entry: Entry,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,wit_bindgen::rt::string::String>;
          /// Export a function that proves selected attributes in a given credential
          /// Returns the selected attributes in the proper order in order to verify the proof,
          /// as each Attribute needs to be verified from their respective Entry.
          fn prove(values: Provables,) -> Result<Proven,wit_bindgen::rt::string::String>;
          /// Export a function that verifies a proof against a public key, nonce and selected attributes
          fn verify(values: Verifiables,) -> Result<bool,wit_bindgen::rt::string::String>;
        }
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        
        #[repr(align(4))]
        struct _RetArea([u8; 20]);
        static mut _RET_AREA: _RetArea = _RetArea([0; 20]);
        
      }
      
    }
  }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:delanocreds"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 4387] = [3, 0, 11, 100, 101, 108, 97, 110, 111, 99, 114, 101, 100, 115, 0, 97, 115, 109, 13, 0, 1, 0, 7, 161, 3, 1, 65, 2, 1, 66, 29, 1, 112, 125, 4, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 3, 0, 0, 1, 112, 1, 4, 0, 5, 101, 110, 116, 114, 121, 3, 0, 2, 1, 112, 125, 4, 0, 5, 110, 111, 110, 99, 101, 3, 0, 4, 1, 112, 125, 4, 0, 5, 112, 114, 111, 111, 102, 3, 0, 6, 1, 112, 3, 4, 0, 8, 115, 101, 108, 101, 99, 116, 101, 100, 3, 0, 8, 1, 112, 125, 1, 112, 3, 1, 112, 1, 1, 114, 4, 10, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 10, 7, 101, 110, 116, 114, 105, 101, 115, 11, 8, 115, 101, 108, 101, 99, 116, 101, 100, 12, 5, 110, 111, 110, 99, 101, 10, 4, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 3, 0, 13, 1, 114, 2, 5, 112, 114, 111, 111, 102, 10, 8, 115, 101, 108, 101, 99, 116, 101, 100, 11, 4, 0, 6, 112, 114, 111, 118, 101, 110, 3, 0, 15, 1, 107, 10, 1, 114, 4, 5, 112, 114, 111, 111, 102, 10, 13, 105, 115, 115, 117, 101, 114, 45, 112, 117, 98, 108, 105, 99, 10, 5, 110, 111, 110, 99, 101, 17, 8, 115, 101, 108, 101, 99, 116, 101, 100, 9, 4, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 3, 0, 18, 1, 114, 2, 8, 110, 121, 109, 112, 114, 111, 111, 102, 10, 5, 110, 111, 110, 99, 101, 17, 4, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 3, 0, 20, 1, 114, 2, 7, 101, 110, 116, 114, 105, 101, 115, 11, 6, 114, 101, 109, 111, 118, 101, 12, 4, 0, 11, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 115, 3, 0, 22, 1, 107, 23, 1, 107, 3, 1, 107, 125, 1, 114, 3, 6, 114, 101, 100, 97, 99, 116, 24, 16, 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 45, 101, 110, 116, 114, 121, 25, 11, 109, 97, 120, 45, 101, 110, 116, 114, 105, 101, 115, 26, 4, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 3, 0, 27, 4, 1, 25, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 0, 11, 11, 1, 0, 5, 116, 121, 112, 101, 115, 3, 0, 0, 7, 185, 7, 1, 65, 12, 1, 66, 29, 1, 112, 125, 4, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 3, 0, 0, 1, 112, 1, 4, 0, 5, 101, 110, 116, 114, 121, 3, 0, 2, 1, 112, 125, 4, 0, 5, 110, 111, 110, 99, 101, 3, 0, 4, 1, 112, 125, 4, 0, 5, 112, 114, 111, 111, 102, 3, 0, 6, 1, 112, 3, 4, 0, 8, 115, 101, 108, 101, 99, 116, 101, 100, 3, 0, 8, 1, 112, 125, 1, 112, 3, 1, 112, 1, 1, 114, 4, 10, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 10, 7, 101, 110, 116, 114, 105, 101, 115, 11, 8, 115, 101, 108, 101, 99, 116, 101, 100, 12, 5, 110, 111, 110, 99, 101, 10, 4, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 3, 0, 13, 1, 114, 2, 5, 112, 114, 111, 111, 102, 10, 8, 115, 101, 108, 101, 99, 116, 101, 100, 11, 4, 0, 6, 112, 114, 111, 118, 101, 110, 3, 0, 15, 1, 107, 10, 1, 114, 4, 5, 112, 114, 111, 111, 102, 10, 13, 105, 115, 115, 117, 101, 114, 45, 112, 117, 98, 108, 105, 99, 10, 5, 110, 111, 110, 99, 101, 17, 8, 115, 101, 108, 101, 99, 116, 101, 100, 9, 4, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 3, 0, 18, 1, 114, 2, 8, 110, 121, 109, 112, 114, 111, 111, 102, 10, 5, 110, 111, 110, 99, 101, 17, 4, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 3, 0, 20, 1, 114, 2, 7, 101, 110, 116, 114, 105, 101, 115, 11, 6, 114, 101, 109, 111, 118, 101, 12, 4, 0, 11, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 115, 3, 0, 22, 1, 107, 23, 1, 107, 3, 1, 107, 125, 1, 114, 3, 6, 114, 101, 100, 97, 99, 116, 24, 16, 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 45, 101, 110, 116, 114, 121, 25, 11, 109, 97, 120, 45, 101, 110, 116, 114, 105, 101, 115, 26, 4, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 3, 0, 27, 3, 1, 25, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 0, 2, 3, 0, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 2, 3, 0, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 2, 3, 0, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 2, 3, 0, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 2, 3, 0, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 2, 3, 0, 0, 5, 110, 111, 110, 99, 101, 2, 3, 0, 0, 5, 101, 110, 116, 114, 121, 2, 3, 0, 0, 6, 112, 114, 111, 118, 101, 110, 1, 66, 36, 2, 3, 2, 1, 1, 4, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 3, 0, 2, 2, 3, 2, 1, 3, 4, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 3, 0, 6, 2, 3, 2, 1, 5, 4, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 3, 0, 8, 2, 3, 2, 1, 6, 4, 0, 5, 110, 111, 110, 99, 101, 3, 0, 10, 2, 3, 2, 1, 7, 4, 0, 5, 101, 110, 116, 114, 121, 3, 0, 12, 2, 3, 2, 1, 8, 4, 0, 6, 112, 114, 111, 118, 101, 110, 3, 0, 14, 1, 112, 125, 1, 106, 1, 16, 1, 115, 1, 64, 1, 5, 110, 111, 110, 99, 101, 11, 0, 17, 4, 0, 13, 103, 101, 116, 45, 110, 121, 109, 45, 112, 114, 111, 111, 102, 1, 18, 1, 112, 1, 1, 107, 9, 1, 64, 3, 10, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 19, 10, 109, 97, 120, 101, 110, 116, 114, 105, 101, 115, 125, 7, 111, 112, 116, 105, 111, 110, 115, 20, 0, 17, 4, 0, 5, 105, 115, 115, 117, 101, 1, 21, 1, 64, 2, 4, 99, 114, 101, 100, 16, 6, 99, 111, 110, 102, 105, 103, 7, 0, 17, 4, 0, 5, 111, 102, 102, 101, 114, 1, 22, 1, 64, 1, 5, 111, 102, 102, 101, 114, 16, 0, 17, 4, 0, 6, 97, 99, 99, 101, 112, 116, 1, 23, 1, 64, 2, 4, 99, 114, 101, 100, 16, 5, 101, 110, 116, 114, 121, 13, 0, 17, 4, 0, 6, 101, 120, 116, 101, 110, 100, 1, 24, 1, 106, 1, 15, 1, 115, 1, 64, 1, 6, 118, 97, 108, 117, 101, 115, 3, 0, 25, 4, 0, 5, 112, 114, 111, 118, 101, 1, 26, 1, 106, 1, 127, 1, 115, 1, 64, 1, 6, 118, 97, 108, 117, 101, 115, 5, 0, 27, 4, 0, 6, 118, 101, 114, 105, 102, 121, 1, 28, 4, 1, 27, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 97, 99, 116, 105, 111, 110, 115, 64, 48, 46, 49, 46, 48, 5, 9, 11, 13, 1, 0, 7, 97, 99, 116, 105, 111, 110, 115, 3, 2, 0, 7, 162, 8, 1, 65, 2, 1, 65, 14, 1, 66, 4, 1, 112, 125, 1, 106, 1, 0, 1, 115, 1, 64, 0, 0, 1, 4, 0, 8, 103, 101, 116, 45, 115, 101, 101, 100, 1, 2, 3, 1, 31, 115, 101, 101, 100, 45, 107, 101, 101, 112, 101, 114, 58, 119, 97, 108, 108, 101, 116, 47, 99, 111, 110, 102, 105, 103, 64, 48, 46, 49, 46, 48, 5, 0, 1, 66, 29, 1, 112, 125, 4, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 3, 0, 0, 1, 112, 1, 4, 0, 5, 101, 110, 116, 114, 121, 3, 0, 2, 1, 112, 125, 4, 0, 5, 110, 111, 110, 99, 101, 3, 0, 4, 1, 112, 125, 4, 0, 5, 112, 114, 111, 111, 102, 3, 0, 6, 1, 112, 3, 4, 0, 8, 115, 101, 108, 101, 99, 116, 101, 100, 3, 0, 8, 1, 112, 125, 1, 112, 3, 1, 112, 1, 1, 114, 4, 10, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 10, 7, 101, 110, 116, 114, 105, 101, 115, 11, 8, 115, 101, 108, 101, 99, 116, 101, 100, 12, 5, 110, 111, 110, 99, 101, 10, 4, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 3, 0, 13, 1, 114, 2, 5, 112, 114, 111, 111, 102, 10, 8, 115, 101, 108, 101, 99, 116, 101, 100, 11, 4, 0, 6, 112, 114, 111, 118, 101, 110, 3, 0, 15, 1, 107, 10, 1, 114, 4, 5, 112, 114, 111, 111, 102, 10, 13, 105, 115, 115, 117, 101, 114, 45, 112, 117, 98, 108, 105, 99, 10, 5, 110, 111, 110, 99, 101, 17, 8, 115, 101, 108, 101, 99, 116, 101, 100, 9, 4, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 3, 0, 18, 1, 114, 2, 8, 110, 121, 109, 112, 114, 111, 111, 102, 10, 5, 110, 111, 110, 99, 101, 17, 4, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 3, 0, 20, 1, 114, 2, 7, 101, 110, 116, 114, 105, 101, 115, 11, 6, 114, 101, 109, 111, 118, 101, 12, 4, 0, 11, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 115, 3, 0, 22, 1, 107, 23, 1, 107, 3, 1, 107, 125, 1, 114, 3, 6, 114, 101, 100, 97, 99, 116, 24, 16, 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 45, 101, 110, 116, 114, 121, 25, 11, 109, 97, 120, 45, 101, 110, 116, 114, 105, 101, 115, 26, 4, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 3, 0, 27, 3, 1, 25, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 1, 2, 3, 0, 1, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 2, 3, 0, 1, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 2, 3, 0, 1, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 2, 3, 0, 1, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 2, 3, 0, 1, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 2, 3, 0, 1, 5, 110, 111, 110, 99, 101, 2, 3, 0, 1, 5, 101, 110, 116, 114, 121, 2, 3, 0, 1, 6, 112, 114, 111, 118, 101, 110, 1, 66, 36, 2, 3, 2, 1, 2, 4, 0, 9, 97, 116, 116, 114, 105, 98, 117, 116, 101, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 9, 112, 114, 111, 118, 97, 98, 108, 101, 115, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 11, 118, 101, 114, 105, 102, 105, 97, 98, 108, 101, 115, 3, 0, 4, 2, 3, 2, 1, 5, 4, 0, 12, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 3, 0, 6, 2, 3, 2, 1, 6, 4, 0, 13, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 3, 0, 8, 2, 3, 2, 1, 7, 4, 0, 5, 110, 111, 110, 99, 101, 3, 0, 10, 2, 3, 2, 1, 8, 4, 0, 5, 101, 110, 116, 114, 121, 3, 0, 12, 2, 3, 2, 1, 9, 4, 0, 6, 112, 114, 111, 118, 101, 110, 3, 0, 14, 1, 112, 125, 1, 106, 1, 16, 1, 115, 1, 64, 1, 5, 110, 111, 110, 99, 101, 11, 0, 17, 4, 0, 13, 103, 101, 116, 45, 110, 121, 109, 45, 112, 114, 111, 111, 102, 1, 18, 1, 112, 1, 1, 107, 9, 1, 64, 3, 10, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 19, 10, 109, 97, 120, 101, 110, 116, 114, 105, 101, 115, 125, 7, 111, 112, 116, 105, 111, 110, 115, 20, 0, 17, 4, 0, 5, 105, 115, 115, 117, 101, 1, 21, 1, 64, 2, 4, 99, 114, 101, 100, 16, 6, 99, 111, 110, 102, 105, 103, 7, 0, 17, 4, 0, 5, 111, 102, 102, 101, 114, 1, 22, 1, 64, 1, 5, 111, 102, 102, 101, 114, 16, 0, 17, 4, 0, 6, 97, 99, 99, 101, 112, 116, 1, 23, 1, 64, 2, 4, 99, 114, 101, 100, 16, 5, 101, 110, 116, 114, 121, 13, 0, 17, 4, 0, 6, 101, 120, 116, 101, 110, 100, 1, 24, 1, 106, 1, 15, 1, 115, 1, 64, 1, 6, 118, 97, 108, 117, 101, 115, 3, 0, 25, 4, 0, 5, 112, 114, 111, 118, 101, 1, 26, 1, 106, 1, 127, 1, 115, 1, 64, 1, 6, 118, 97, 108, 117, 101, 115, 5, 0, 27, 4, 0, 6, 118, 101, 114, 105, 102, 121, 1, 28, 4, 1, 27, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 97, 99, 116, 105, 111, 110, 115, 64, 48, 46, 49, 46, 48, 5, 10, 4, 1, 31, 100, 101, 108, 97, 110, 111, 58, 119, 97, 108, 108, 101, 116, 47, 100, 101, 108, 97, 110, 111, 99, 114, 101, 100, 115, 64, 48, 46, 49, 46, 48, 4, 0, 11, 17, 1, 0, 11, 100, 101, 108, 97, 110, 111, 99, 114, 101, 100, 115, 3, 4, 0, 0, 142, 14, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123, 34, 119, 111, 114, 108, 100, 115, 34, 58, 123, 34, 100, 101, 108, 97, 110, 111, 99, 114, 101, 100, 115, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 32, 68, 101, 108, 97, 110, 111, 99, 114, 101, 100, 115, 32, 119, 111, 114, 108, 100, 32, 102, 111, 114, 32, 116, 104, 101, 32, 99, 111, 109, 112, 111, 110, 101, 110, 116, 32, 116, 111, 32, 116, 97, 114, 103, 101, 116, 46, 34, 125, 125, 44, 34, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 34, 58, 123, 34, 116, 121, 112, 101, 115, 34, 58, 123, 34, 116, 121, 112, 101, 115, 34, 58, 123, 34, 97, 116, 116, 114, 105, 98, 117, 116, 101, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 110, 32, 97, 116, 116, 114, 105, 98, 117, 116, 101, 32, 105, 115, 32, 97, 32, 51, 50, 32, 98, 121, 116, 101, 115, 32, 104, 97, 115, 104, 32, 118, 97, 108, 117, 101, 34, 125, 44, 34, 105, 115, 115, 117, 101, 45, 111, 112, 116, 105, 111, 110, 115, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 73, 115, 115, 117, 101, 114, 32, 99, 111, 110, 102, 105, 103, 58, 32, 68, 101, 102, 97, 117, 108, 116, 32, 99, 111, 110, 102, 105, 103, 32, 99, 114, 101, 97, 116, 101, 115, 32, 40, 105, 115, 115, 117, 101, 115, 41, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 116, 111, 32, 121, 111, 117, 114, 115, 101, 108, 102, 46, 92, 110, 80, 114, 111, 118, 105, 100, 101, 32, 97, 32, 99, 111, 110, 102, 105, 103, 32, 116, 111, 32, 111, 102, 102, 101, 114, 32, 105, 116, 32, 116, 111, 32, 115, 111, 109, 101, 111, 110, 101, 32, 101, 108, 115, 101, 39, 115, 32, 110, 121, 109, 44, 32, 97, 110, 100, 32, 111, 112, 116, 105, 111, 110, 97, 108, 108, 121, 32, 118, 101, 114, 105, 102, 121, 32, 105, 116, 32, 119, 105, 116, 104, 32, 97, 32, 110, 111, 110, 99, 101, 46, 34, 125, 44, 34, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 115, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 73, 102, 32, 121, 111, 117, 32, 119, 97, 110, 116, 32, 116, 111, 32, 114, 101, 100, 97, 99, 116, 32, 97, 110, 32, 69, 110, 116, 114, 121, 32, 99, 111, 110, 116, 97, 105, 110, 105, 110, 103, 32, 97, 110, 32, 65, 116, 116, 114, 105, 98, 117, 116, 101, 44, 92, 110, 99, 111, 110, 115, 116, 114, 117, 99, 116, 32, 97, 32, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 32, 114, 101, 99, 111, 114, 100, 32, 119, 105, 116, 104, 32, 97, 108, 108, 32, 69, 110, 116, 114, 105, 101, 115, 32, 97, 110, 100, 32, 116, 104, 101, 32, 108, 105, 115, 116, 32, 111, 102, 32, 65, 116, 116, 114, 105, 98, 117, 116, 101, 115, 32, 116, 111, 32, 114, 101, 100, 97, 99, 116, 46, 34, 125, 44, 34, 111, 102, 102, 101, 114, 45, 99, 111, 110, 102, 105, 103, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 67, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 32, 111, 102, 32, 97, 110, 32, 79, 102, 102, 101, 114, 46, 32, 67, 97, 110, 32, 115, 101, 116, 32, 51, 32, 116, 104, 105, 110, 103, 115, 58, 92, 110, 49, 41, 32, 119, 105, 116, 104, 111, 117, 116, 45, 97, 116, 116, 114, 105, 98, 117, 116, 101, 58, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 114, 101, 100, 97, 99, 116, 97, 98, 108, 101, 32, 114, 101, 99, 111, 114, 100, 32, 111, 102, 32, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 32, 116, 111, 32, 114, 101, 100, 97, 99, 116, 44, 92, 110, 50, 41, 32, 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 45, 101, 110, 116, 114, 121, 58, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 105, 110, 103, 108, 101, 32, 97, 100, 100, 105, 116, 105, 111, 110, 97, 108, 32, 101, 110, 116, 114, 121, 44, 92, 110, 51, 41, 32, 109, 97, 120, 45, 101, 110, 116, 114, 105, 101, 115, 58, 32, 116, 104, 101, 32, 109, 97, 120, 105, 109, 117, 109, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 101, 110, 116, 114, 105, 101, 115, 32, 116, 104, 101, 32, 100, 101, 108, 101, 103, 97, 116, 101, 100, 32, 112, 97, 114, 116, 121, 32, 99, 97, 110, 32, 97, 100, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 46, 34, 44, 34, 105, 116, 101, 109, 115, 34, 58, 123, 34, 109, 97, 120, 45, 101, 110, 116, 114, 105, 101, 115, 34, 58, 34, 79, 112, 116, 105, 111, 110, 97, 108, 108, 121, 32, 114, 101, 100, 117, 99, 101, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 101, 110, 116, 114, 105, 101, 115, 32, 116, 104, 97, 116, 32, 99, 97, 110, 32, 98, 101, 32, 97, 100, 100, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 46, 34, 125, 125, 125, 125, 44, 34, 97, 99, 116, 105, 111, 110, 115, 34, 58, 123, 34, 102, 117, 110, 99, 115, 34, 58, 123, 34, 103, 101, 116, 45, 110, 121, 109, 45, 112, 114, 111, 111, 102, 34, 58, 34, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 97, 99, 116, 105, 118, 101, 32, 78, 121, 109, 32, 111, 102, 32, 116, 104, 101, 32, 99, 111, 109, 112, 111, 110, 101, 110, 116, 46, 34, 44, 34, 105, 115, 115, 117, 101, 34, 58, 34, 73, 115, 115, 117, 101, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 69, 110, 116, 114, 121, 32, 116, 111, 32, 97, 32, 78, 121, 109, 32, 119, 105, 116, 104, 32, 109, 97, 120, 105, 109, 117, 109, 32, 101, 110, 116, 114, 105, 101, 115, 46, 92, 110, 66, 121, 32, 100, 101, 102, 97, 117, 108, 116, 32, 105, 115, 115, 117, 101, 115, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 116, 111, 32, 121, 111, 117, 114, 32, 111, 119, 110, 32, 78, 121, 109, 46, 32, 84, 111, 32, 105, 115, 115, 117, 101, 32, 116, 111, 32, 111, 116, 104, 101, 114, 115, 44, 32, 115, 101, 116, 32, 116, 104, 101, 32, 111, 112, 116, 105, 111, 110, 115, 32, 116, 111, 32, 116, 104, 101, 105, 114, 32, 110, 121, 109, 112, 114, 111, 111, 102, 32, 97, 110, 100, 32, 111, 112, 116, 105, 111, 110, 97, 108, 108, 121, 32, 116, 104, 101, 32, 110, 111, 110, 99, 101, 32, 121, 111, 117, 32, 103, 97, 118, 101, 32, 116, 104, 101, 109, 46, 34, 44, 34, 111, 102, 102, 101, 114, 34, 58, 34, 67, 114, 101, 97, 116, 101, 32, 97, 110, 32, 111, 102, 102, 101, 114, 32, 102, 111, 114, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 119, 105, 116, 104, 32, 105, 116, 115, 32, 103, 105, 118, 101, 110, 32, 101, 110, 116, 114, 105, 101, 115, 32, 97, 110, 100, 32, 97, 32, 103, 105, 118, 101, 110, 32, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 46, 34, 44, 34, 97, 99, 99, 101, 112, 116, 34, 58, 34, 65, 99, 99, 101, 112, 116, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 111, 102, 102, 101, 114, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 116, 104, 101, 32, 97, 99, 99, 101, 112, 116, 101, 32, 67, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 98, 121, 116, 101, 115, 34, 44, 34, 101, 120, 116, 101, 110, 100, 34, 58, 34, 69, 120, 116, 101, 110, 100, 32, 97, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 32, 119, 105, 116, 104, 32, 97, 32, 110, 101, 119, 32, 101, 110, 116, 114, 121, 34, 44, 34, 112, 114, 111, 118, 101, 34, 58, 34, 69, 120, 112, 111, 114, 116, 32, 97, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 116, 104, 97, 116, 32, 112, 114, 111, 118, 101, 115, 32, 115, 101, 108, 101, 99, 116, 101, 100, 32, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 32, 105, 110, 32, 97, 32, 103, 105, 118, 101, 110, 32, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108, 92, 110, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 115, 101, 108, 101, 99, 116, 101, 100, 32, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 32, 105, 110, 32, 116, 104, 101, 32, 112, 114, 111, 112, 101, 114, 32, 111, 114, 100, 101, 114, 32, 105, 110, 32, 111, 114, 100, 101, 114, 32, 116, 111, 32, 118, 101, 114, 105, 102, 121, 32, 116, 104, 101, 32, 112, 114, 111, 111, 102, 44, 92, 110, 97, 115, 32, 101, 97, 99, 104, 32, 65, 116, 116, 114, 105, 98, 117, 116, 101, 32, 110, 101, 101, 100, 115, 32, 116, 111, 32, 98, 101, 32, 118, 101, 114, 105, 102, 105, 101, 100, 32, 102, 114, 111, 109, 32, 116, 104, 101, 105, 114, 32, 114, 101, 115, 112, 101, 99, 116, 105, 118, 101, 32, 69, 110, 116, 114, 121, 46, 34, 44, 34, 118, 101, 114, 105, 102, 121, 34, 58, 34, 69, 120, 112, 111, 114, 116, 32, 97, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 116, 104, 97, 116, 32, 118, 101, 114, 105, 102, 105, 101, 115, 32, 97, 32, 112, 114, 111, 111, 102, 32, 97, 103, 97, 105, 110, 115, 116, 32, 97, 32, 112, 117, 98, 108, 105, 99, 32, 107, 101, 121, 44, 32, 110, 111, 110, 99, 101, 32, 97, 110, 100, 32, 115, 101, 108, 101, 99, 116, 101, 100, 32, 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 34, 125, 125, 125, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}
