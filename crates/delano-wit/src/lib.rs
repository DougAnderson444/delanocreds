cargo_component_bindings::generate!();

use std::sync::Mutex;

use bindings::get_seed;
use bindings::Guest;
use delano_keys::kdf::Manager;
use delano_keys::kdf::Zeroizing;
use delanocreds::CredentialCompressed;
use delanocreds::MaxCardinality;
use delanocreds::MaxEntries;
use delanocreds::NymProof;
use delanocreds::{Entry, Issuer, Nonce};

// We cannot have &self in the WIT model
// so we use static variables to store the state between functions
// See https://crates.io/crates/lazy_static
lazy_static::lazy_static! {
  static ref ISSUER: Mutex<Issuer> = {
        let seed = get_seed();
        // derive secret key fromseed using delano_keys
        let seed = Zeroizing::new([69u8; 32]);
        let manager: Manager = Manager::from_seed(seed);

        // Check to ensure the VK generated by the sk expanded matches those derived from pk_g1 and
        // pk_2
        let account = manager.account(1);

        let expanded = account.expand_to(MaxEntries::default().into());

        Mutex::new(Issuer::new_with_secret(expanded, MaxCardinality::default()))
    };
}

struct Component;

impl Guest for Component {
    /// Issue a credential
    ///
    /// `nonce` - If the Nonce is 32 bytes long, it will be directly converted into a Scalar, otherwise it
    /// will be hashed into 32 byte digest then converted into a Scalar
    ///
    /// # Returns
    /// CBOR encoded CredentialCompressed bytes.
    fn issue(
        nymproof: Vec<u8>,
        attributes: Vec<bindings::component::delano_wit::types::Attribute>,
        maxentries: u8,
        nonce: Option<Vec<u8>>,
    ) -> Result<Vec<u8>, String> {
        let mut issuer = ISSUER.lock().unwrap();

        let entry = Entry::try_from(attributes).map_err(|e| e.to_string())?;
        let nym_proof: NymProof =
            ciborium::from_reader(&nymproof[..]).map_err(|e| e.to_string())?;

        // preprocess the nonce bytes according to length
        // if nonce is 32 bytes, convert it directly into a Scalar
        // otherwise, hash it into a 32 byte digest, then convert it into a Scalar
        let nonce = match nonce {
            Some(nonce) => {
                if nonce.len() == 32 {
                    let mut bytes = [0u8; 32];
                    bytes.copy_from_slice(&nonce[..]);
                    Some(Nonce::from(bytes))
                } else {
                    Some(Nonce::from(&nonce))
                }
            }
            None => None,
        };

        let cred = issuer
            .credential()
            .with_entry(entry)
            .max_entries(&MaxEntries::default())
            .issue_to(&nym_proof, nonce.as_ref())
            .map_err(|e| e.to_string())?;

        // serialize and return the cred
        let mut bytes = Vec::new();
        let cred = ciborium::into_writer(&cred, &mut bytes).map_err(|e| e.to_string())?;

        Ok(bytes)
    }

    /// Offer
    fn offer(
        attributes: Vec<bindings::component::delano_wit::types::Attribute>,
    ) -> Result<Vec<u8>, String> {
        let mut issuer = ISSUER.lock().unwrap();

        // try to convert the Vec<Attribute> into a delanocreds::Entry
        let entry = match Entry::try_from(attributes) {
            Ok(entry) => entry,
            Err(e) => return Err(e.to_string()),
        };

        todo!()
    }

    /// Accept
    fn accept(credential: Vec<u8>) -> Result<Vec<u8>, String> {
        unimplemented!()
    }

    /// Prove
    fn prove(values: bindings::component::delano_wit::types::Provables) -> Result<Vec<u8>, String> {
        unimplemented!()
    }

    /// Verify
    fn verify(values: bindings::component::delano_wit::types::Verifiables) -> Result<bool, String> {
        unimplemented!()
    }
}
